#
# Small working subset of
# Knowledge base for Auto-WEKA like classifier construction by HTN planning
#
# For Auto-WEKA see:
# Chris Thornton Frank Hutter Holger H. Hoos Kevin Leyton-Brown
# Auto-WEKA: Combined Selection and Hyperparameter Optimization of Classiï¬�cation Algorithms
#


[NonFunctionalRequirements]

int Price: +


[Constants]

-1:Number
0.000000000001:Number
0.00000000001:Number
0.0000000001:Number
0.000000001:Number
0.00000001:Number
0.0000001:Number
0.000001:Number
0.00001:Number
0.0001:Number
0.001:Number
0.01:Number
0.0:Number
0.1:Number
0.2:Number
0.3:Number
0.4:Number
0.5:Number
0.55:Number
0.6:Number
0.65:Number
0.7:Number
0.75:Number
0.8:Number
0.85:Number
0.9:Number
0.95:Number
0.99:Number
1.0:Number
1.1:Number
1.2:Number
1.3:Number
1.4:Number
1.5:Number
1.8:Number
2.0:Number
2.5:Number
2.6:Number
3.0:Number
3.4:Number
3.5:Number
4.0:Number
4.2:Number
4.5:Number
5.0:Number
0:Number
1:Number
2:Number
3:Number
4:Number
5:Number
6:Number
7:Number
8:Number
9:Number
10:Number
12:Number
13:Number
14:Number
15:Number
16:Number
18:Number
20:Number
25:Number
30:Number
32:Number
40:Number
50:Number
60:Number
62:Number
64:Number
70:Number
75:Number
80:Number
90:Number
100:Number
120:Number
125:Number
128:Number
150:Number
175:Number
200:Number
256:Number
100:Number
125:Number
250:Number
500:Number
512:Number
1000:Number
1024:Number
5000:Number
10000:Number
20000:Number
50000:Number

null:String

-A:String
-B:String
-C:String
-D:String
-E:String
-F:String
-H:String
-I:String
-J:String
-K:String
-L:String
-M:String
-N:String
-O:String
-P:String
-Q:String
-R:String
-S:String
-U:String
-V:String
-W:String
-depth:String
--:String


### BASE CLASSIFIERS ###

weka.classifiers.bayes.BayesNet:String
weka.classifiers.bayes.NaiveBayes:String
weka.classifiers.bayes.NaiveBayesMultinomial:String

weka.classifiers.functions.GaussianProcesses:String
weka.classifiers.functions.LinearRegression:String
weka.classifiers.functions.Logistic:String
weka.classifiers.functions.MultilayerPerceptron:String
weka.classifiers.functions.SGD:String
weka.classifiers.functions.SimpleLinearRegression:String
weka.classifiers.functions.SimpleLogistic:String
weka.classifiers.functions.SMO:String
weka.classifiers.functions.SMOreg:String
weka.classifiers.functions.VotedPerceptron:String

weka.classifiers.functions.LibSVM:String

weka.classifiers.lazy.IBk:String
weka.classifiers.lazy.KStar:String

weka.classifiers.rules.DecisionTable:String
weka.classifiers.rules.JRip:String
weka.classifiers.rules.M5Rules:String
weka.classifiers.rules.OneR:String
weka.classifiers.rules.PART:String
weka.classifiers.rules.ZeroR:String

weka.classifiers.trees.DecisionStump:String
weka.classifiers.trees.J48:String
weka.classifiers.trees.LMT:String
weka.classifiers.trees.M5P:String
weka.classifiers.trees.RandomForest:String
weka.classifiers.trees.RandomTree:String
weka.classifiers.trees.REPTree:String


### BASE CLASSIFIERS PARAMETER ###

# Bayes Net searchAlgorithm: Option -Q
weka.classifiers.bayes.net.search.local.K2:String
weka.classifiers.bayes.net.search.local.HillClimber:String
weka.classifiers.bayes.net.search.local.LAGDHillClimber:String
weka.classifiers.bayes.net.search.local.SimulatedAnnealing:String
weka.classifiers.bayes.net.search.local.TabuSearch:String
weka.classifiers.bayes.net.search.local.TAN:String

# Multilayer Perceptron Hidden Layer Type: Option -H
#a:String
i:String
o:String
t:String

# Gaussian Processes, SMO, SMOreg kernel: Option -K
weka.classifiers.functions.supportVector.NormalizedPolyKernel:String
weka.classifiers.functions.supportVector.PolyKernel:String
weka.classifiers.functions.supportVector.Puk:String
weka.classifiers.functions.supportVector.RBFKernel:String

# SMOreg regOptimizer: Option -I
weka.classifiers.functions.supportVector.RegSMO:String
weka.classifiers.functions.supportVector.RegSMOImproved:String

# KStar missingMode: Option -M
a:String
d:String
m:String
n:String

# Decision Table search: Option -S
weka.attributeSelection.BestFirst:String
weka.attributeSelection.GreedyStepwise:String
weka.attributeSelection.Ranker:String

# Decision Table evaluationMeasure: Option -E
acc:string
rmse:String
mae:String
auc:String


### META CLASSIFIERS ###

weka.classifiers.lazy.LWL:String
weka.classifiers.meta.AdditiveRegression:String
weka.classifiers.meta.AdaBoostM1:String
weka.classifiers.meta.AttributeSelectedClassifier:String
weka.classifiers.meta.Bagging:String
weka.classifiers.meta.ClassificationViaRegression:String
weka.classifiers.meta.LogitBoost:String
weka.classifiers.meta.MultiClassClassifier:String
weka.classifiers.meta.RandomCommittee:String
weka.classifiers.meta.RandomSubSpace:String


#META CLASSIFIERS PARAMETER ###

# Locally Weighted Learning nearestNeighbourSearch: Option -A
weka.core.neighboursearch.LinearNNSearch:String


# Other meta methods (not in AutoWEKA)
# Nested Dichotomy Services
weka.classifiers.meta.nestedDichotomies.ND:String
weka.classifiers.meta.nestedDichotomies.RandomPairND:String
weka.classifiers.meta.nestedDichotomies.ClassBalancedND:String
weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:String
weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:String


### ENSEMBLE CLASSIFIERS ###

weka.classifiers.meta.Vote:String
weka.classifiers.meta.Stacking:String

# Other ensemble methods (not in AutoWEKA)
weka.classifiers.meta.MultiBoostAB:String


### ENSEMBLE CLASSIFIERS PARAMETER ###

# Voting combinationRule: Option -R
AVG:string
PROD:String
MAJ:String
MIN:String
MAX:String


[Types]

Thing;
Image;
JPGImage;Image
BMPImage;Image
GIFImage;Image
FeatureVector;
Number;
Value;
Instances;
Filter;
Classes;
Boolean;
Spam;Boolean
Text;Boolean


[Services]

### Helper Services ###
noop;;;;;(0)

inheritInstanceProp	; x:Instances,y:Instances; ; Instances(x) & assigned(x,y) ; Instances(y);(0)

copyNormalizedInstances;x:Thing,y:Thing;;;Instances(y) & normalized(y);(0)
split;	x:Instances; split:List<Instances>; Instances(x); List<Instances>(split); (0)
retrieveTrain;	s:List<Instances>; train:Instances; List<Instances>(s); Instances(train); (0)
retrieveTest;	s:List<Instances>; test:Instances; List<Instances>(s); Instances(test); (0)

assignTo			; s1:String; s2:String; ; assigned(s1,s2); (0)

getOptionList; 		; o:List<String>; ; List<String>(o); (0)

addOption			; oList:List<String>, o:String,currentMax:String;; List<String>(oList) & !in(oList, o); in(oList, o); (0)
addOptionPair		; oList:List<String>, o:String, v:Value,currentMax:String;; List<String>(oList) & !in(oList, o); in(oList, o) & optVal(oList,o,v); (0)

addSingleParam		; oList:List<String>, p:String; ; List<String>(oList) ; in(oList, p) ; (0)
noaddSingleParam	; oList:List<String>, p:String; ; List<String>(oList) ; notin(oList, p) ; (0)
addValuedParam		; oList:List<String>, p:String, v:Value; ; List<String>(oList) ; in(oList, p) & optVal(oList,p,v); (0)
noaddValuedParam	; oList:List<String>, p:String, v:Value; ; List<String>(oList) ; notin(oList, p) & optVal(oList,p,v); (0)

concatenateWithName	; cn:String, oLocal:List<String>; param:String; List<String>(oLocal); String(param); (0)
concatenate			; oLocal:List<String>; param:String; List<String>(oLocal); String(param); (0)
appendOptions		; l1:List<String>, l2:List<String>; ; List<String>(l1) & List<String>(l2);appended(l1,l2);(0)

compileOptionListToArray; oList:List<String>; oArray:String[]; List<String>(oList); String[](oArray); (0)

# Evaluation
weka.classifiers.evaluation.Evaluation:__construct;test:Instances;e:Evaluation;Instances(test);Evaluation(e);(0)
weka.classifiers.evaluation.Evaluation:crossValidateModel;e:Evaluation,c:Classifier,x:Instances,f:Folds,r:Random;;Evaluation(e) & Classifier(c)& Instances(x) & Random(r) & Folds(f);;(0)
weka.classifiers.evaluation.Evaluation:evaluateModel;e:Evaluation,c:Classifier,x:Instances;;Evaluation(e) & Classifier(c)& Instances(x);;(0)
weka.classifiers.evaluation.Evaluation:pctCorrect;e:Evaluation;q:Double;Evaluation(e);Double(q);(0)


### DATA PREPROCESSING ###
####### weka.filters.Filter:useFilter;x:Instances,p:DataPreprocessor;z:Instances;DataPreprocessor(p) & Instances(x); Instances(z);(0)

weka.filters.unsupervised.attribute.Normalize:__construct;;p:DataPreprocessor;;DataPreprocessor(p);(0)
weka.filters.unsupervised.attribute.Normalize:setInputFormat;p:DataPreprocessor,x:Instances;;DataPreprocessor(p) & Instances(x);normalized(x);(0)
weka.filters.unsupervised.attribute.Standardize:__construct;;p:DataPreprocessor;;DataPreprocessor(p);(0)
weka.filters.unsupervised.attribute.Standardize:setInputFormat;p:DataPreprocessor,x:Instances;;DataPreprocessor(p) & Instances(x);standardized(x);(0)


### FEATURE PREPROCESSING ###

# Generic filter construction and application
weka.filters.supervised.attribute.AttributeSelection:__construct;;f;;FeatureSelectionFilter(f);(0)
weka.filters.supervised.attribute.AttributeSelection:setOptions;f,o;;FeatureSelectionFilter(f) & String[](o); optSet(f);(0)

weka.filters.Filter:setInputFormat;	f:Filter,x:Instances; b:Boolean; Instances(x) ; FilterFormat(x,b);(0)
weka.filters.Filter:useFilter;	x:Instances,f:Filter; x_new:Instances; Instances(x) & FeatureSelectionFilter(f) ; Instances(x_new) & reduced(x_new);(0)

####### Beware! Data preprocessing would use same service, service name is unique, i.e. only first service is tried.


### CLASSIFIER INITIALIZATION ###

# Classifier and their configuration methods
# Base Classifier
weka.classifiers.bayes.BayesNet:__construct;;c;;Classifier(c);(0)
weka.classifiers.bayes.BayesNet:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.bayes.NaiveBayes:__construct;;c;;Classifier(c);(0)
weka.classifiers.bayes.NaiveBayes:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.bayes.NaiveBayesMultinomial:__construct;;c;;Classifier(c);(0)
weka.classifiers.bayes.NaiveBayesMultinomial:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.GaussianProcesses:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.GaussianProcesses:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.LinearRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.LinearRegression:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.Logistic:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.Logistic:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.MultilayerPerceptron:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.MultilayerPerceptron:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
####### weka.classifiers.functions.MultilayerPerceptron:setHiddenLayers;c:Classifier,h:String;;Classifier(c) & String(h);optSet(c);(0)
weka.classifiers.functions.SGD:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SGD:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.LibSVM:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.LibSVM:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SimpleLinearRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SimpleLinearRegression:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SimpleLogistic:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SimpleLogistic:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SMO:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SMO:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SMOreg:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SMOreg:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.VotedPerceptron:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.VotedPerceptron:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.lazy.IBk:__construct;;c;;Classifier(c);(0)
weka.classifiers.lazy.IBk:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.lazy.KStar:__construct;;c;;Classifier(c);(0)
weka.classifiers.lazy.KStar:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.DecisionTable:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.DecisionTable:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.JRip:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.JRip:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.M5Rules:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.M5Rules:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.OneR:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.OneR:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.PART:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.PART:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.ZeroR:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.ZeroR:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.DecisionStump:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.DecisionStump:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.J48:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.J48:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.LMT:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.LMT:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.M5P:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.M5P:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.RandomForest:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.RandomForest:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.RandomTree:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.RandomTree:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.REPTree:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.REPTree:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)

# Nested Dichotomy Services
weka.classifiers.meta.nestedDichotomies.ND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.ND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.RandomPairND:__construct;;c:Classifier;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.RandomPairND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.ClassBalancedND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.ClassBalancedND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:setOptions;c,o;;Classifier(c) & String[](o);;(0)

# Meta Classifier
weka.classifiers.lazy.LWL:__construct;;c;;Classifier(c);(0)
weka.classifiers.lazy.LWL:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.AdditiveRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.AdditiveRegression:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.AdaBoostM1:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.AdaBoostM1:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.AttributeSelectedClassifier:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.AttributeSelectedClassifier:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.Bagging:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.Bagging:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.ClassificationViaRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.ClassificationViaRegression:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.LogitBoost:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.LogitBoost:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.MultiClassClassifier:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.MultiClassClassifier:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.RandomCommittee:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.RandomCommittee:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.RandomSubSpace:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.RandomSubSpace:setOptions;c,o;;Classifier(c) & String[](o);;(0)

# Ensemble Classifier
weka.classifiers.meta.Vote:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.Vote:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.Stacking:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.Stacking:setOptions;c,o;;Classifier(c) & String[](o);;(0)

# Other ensemble methods
weka.classifiers.meta.MultiBoostAB:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.MultiBoostAB:setOptions;c,o;;Classifier(c) & String[](o);;(0)


[Methods]

### Helper Methods ###

# optional parameters
addOptionalParameterNo					; addOptParam(o,p);						o,p; ; noaddSingleParam(o,p)
addOptionalParameterYes					; addOptParam(o,p);						o,p; ; addSingleParam(o,p)
addOptionalValuedParameterNo			; addOptValuedParam(o,p,v);				o,p,v; ; noaddValuedParam(o,p,v)
addOptionalValuedParameterYes			; addOptValuedParam(o,p,v);				o,p,v; ; addValuedParam(o,p,v)
# p | q in {REMOVE_PREV} (p must be present if q is not)
condAddOptionalParameterNo				; condAddOptParam(o,p,q);				o,p,q; in(o,q) ; addOptParam(o,p)
condAddOptionalParameterYes				; condAddOptParam(o,p,q);				o,p,q; notin(o,q) ; addSingleParam(o,p)
condAddOptionalValuedParameterNo		; condAddOptValuedParam(o,p,v,q);		o,p,v,q; in(o,q) ; addOptValuedParam(o,p,v)
condAddOptionalValuedParameterYes		; condAddOptValuedParam(o,p,v,q);		o,p,v,q; notin(o,q) ; addValuedParam(o,p,v)
# p | q in {REMOVED} (p must be present if q is present)
negCondAddOptionalParameterNo			; negCondAddOptParam(o,p,q);			o,p,q; in(o,q) ; addSingleParam(o,p)
negCondAddOptionalParameterYes			; negCondAddOptParam(o,p,q);			o,p,q; notin(o,q) ; addOptParam(o,p)
negCondAddOptionalValuedParameterNo		; negCondAddOptValuedParam(o,p,v,q);	o,p,v,q; in(o,q) ; addValuedParam(o,p,v)
negCondAddOptionalValuedParameterYes	; negCondAddOptValuedParam(o,p,v,q);	o,p,v,q; notin(o,q) ; addOptValuedParam(o,p,v)
# mandatory parameters
addMandatoryParameter					; addMandatParam(o,p);					o,p; ; addSingleParam(o,p)
addMandatoryValuedParameter				; addMandatValuedParam(o,p,v);			o,p,v; ; addValuedParam(o,p,v)


### Main ###

#inductionMethod;	induce(x);	x,f,r,c,q; Instances(x) & Folds(f) & Random(r) ; preprocessData(x) -> preprocessFeatures(x) -> createAndValidateClassifier(x,f,r,c,q)
inductionMethod;	induce(x);	x,x1,x2,c; Instances(x) ; preprocessData(x,x1) -> preprocessFeatures(x1,x2) -> createClassifier(x2,c)
wekaClassification;	createClassifier(x,c); x,c; Instances(x); wekaCreateClassifier(c)


### DATA PREPROCESSORS ###

wekaPreprocessData; preprocessData(x,x_new); x,x_new; Instances(x) ; assignTo(x,x_new) -> inheritInstanceProp(x,x_new)
#wekaNormalize; preprocessData(x); x,p; !normalized(x) ; weka.filters.unsupervised.attribute.Normalize:__construct(p) -> weka.filters.unsupervised.attribute.Normalize:setInputFormat(p,x) -> weka.filters.Filter:useFilter(x,p,x) -> preprocessData(x) 
#wekaStandardize; preprocessData(x); x,p; !standardized(x) ; weka.filters.unsupervised.attribute.Standardize:__construct(p) -> weka.filters.unsupervised.attribute.Standardize:setInputFormat(p,x) -> weka.filters.Filter:useFilter(x,p,x) -> preprocessData(x)


### FEATURE PREPROCESSORS ###

# No preprocessing
#wekaPreprocessFeatures; preprocessFeatures(x,x_new); x,x_new; Instances(x) ; assignTo(x,x_new) -> inheritInstanceProp(x,x_new)
# Do preprocessing
wekaPreprocessFeatures; preprocessFeatures(x,x_new); x,f,b,x_new; Instances(x) & !reduced(x) ; wekaCreateFeaturePreprocessor(f) -> weka.filters.Filter:setInputFormat(f,x,b) -> weka.filters.Filter:useFilter(x,f,x_new)

# Generic Attribute Selection
wekaAttributeSelection	; wekaCreateFeaturePreprocessor(f); f,oList,oArray; ; weka.filters.supervised.attribute.AttributeSelection:__construct(f) -> getOptionList(oList) -> getWekaASConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.filters.supervised.attribute.AttributeSelection:setOptions(f,oArray)
wekaAttributeSelection	; getWekaASConfig0(o);	o,fsn,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeFeatureSubsetSearch(fsn, oLocal) -> concatenateWithName(fsn, oLocal, val) -> addMandatValuedParam(o, '-S', val) -> getWekaASConfig1(o)
wekaAttributeSelection	; getWekaASConfig1(o);	o,fen,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeFeatureSubsetEvaluation(fen, oLocal) -> concatenateWithName(fen, oLocal, val) -> addMandatValuedParam(o, '-E', val)
wekaAttributeSelection	; getWekaASConfig0(o);	o,fsn,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeFeatureRankingSearch(fsn, oLocal) -> concatenateWithName(fsn, oLocal, val) -> addMandatValuedParam(o, '-S', val) -> getWekaASConfig2(o)
wekaAttributeSelection	; getWekaASConfig2(o);	o,fen,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeFeatureRankingEvaluation(fen, oLocal) -> concatenateWithName(fen, oLocal, val) -> addMandatValuedParam(o, '-E', val)


### FEATURE SELECTION SEARCHER ###

# Best First
wekaBF;	wekaParametrizeFeatureSubsetSearch(fsn,oList); fsn,oList; ; assignTo('weka.attributeSelection.BestFirst',fsn) -> getWekaBFConfig0(oList)
# -D <int> mandatory
wekaBFOptsDirection			; getWekaBFConfig0(o);	o,int; BFDirection(int) ; addMandatValuedParam(o, '-D', int) -> getWekaBFConfig1(o)
# -N <int> mandatory
wekaBFOptsSearchTermination	; getWekaBFConfig1(o);	o,int; BFSearchTermination(int) ; addMandatValuedParam(o, '-N', int) -> getWekaBFConfig2(o)
# -S 1 mandatory (was 0, but 1 makes more sense)
wekaBFOptsLookupCacheSize	; getWekaBFConfig2(o);	o,int; ; addMandatValuedParam(o, '-S', '1')

# Greedy Stepwise
#wekaGS;	wekaParametrizeFeatureSubsetSearch(fsn,oList); fsn,oList; ; assignTo('weka.attributeSelection.GreedyStepwise',fsn) -> getWekaGSConfig0(oList)
# -C, -B, -R optional
wekaGSOptsConservForwSel	; getWekaGSConfig0(o);	o,int; ; addOptParam(o, '-C') -> getWekaGSConfig1(o)
wekaGSOptsSearchBackwards	; getWekaGSConfig1(o);	o,int; ; addOptParam(o, '-B') -> getWekaGSConfig2(o)
wekaGSOptsGenerateRanking	; getWekaGSConfig2(o);	o,int; ; addOptParam(o, '-R') -> getWekaGSConfig3(o)
# -N <int> mandatory, only if -R not used
wekaGSOptsSearchTermination	; getWekaGSConfig3(o);	o,int;  notin(o,'-R') & GSNumToSelect(int) ; addMandatValuedParam(o, '-N', int)
# -T <float> mandatory, only if -R used
wekaGSOptsThreshold			; getWekaGSConfig3(o);	o,float;  in(o,'-R') & GSThreshold(float) ; addMandatValuedParam(o, '-T', float)

# Ranker
#wekaRank;	wekaParametrizeFeatureRankingSearch(fsn,oList); fsn,oList; ; assignTo('weka.attributeSelection.Ranker',fsn) -> getWekaRankConfig0(oList)
# -T <float> mandatory
wekaRankOptsThreshold			; getWekaRankConfig0(o);	o,float;  RankThreshold(float) ; addMandatValuedParam(o, '-T', float)


### FEATURE SELECTION EVALUATORS ###

# Correlation-based Feature Subset Selection
wekaCfsSubsetEval;	wekaParametrizeFeatureSubsetEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.CfsSubsetEval',fen) -> getWekaCfsSubsetEvalConfig0(oList)
# -M, -L optional
wekaCfsSubsetEvalOptsMissingSeparate	; getWekaCfsSubsetEvalConfig0(o);	o; ; addOptParam(o, '-M') -> getWekaCfsSubsetEvalConfig1(o)
wekaCfsSubsetEvalOptsLocallyPredictive	; getWekaCfsSubsetEvalConfig1(o);	o; ; addOptParam(o, '-L')

# Correlation Attribute Evaluation
#wekaCorrAttrEval;	wekaParametrizeFeatureRankingEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.CorrelationAttributeEval',fen)
# No parameter

# Gain Ratio Attribute Evaluation
#wekaGainRatioAE;	wekaParametrizeFeatureRankingEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.GainRatioAttributeEval',fen)
# No parameter

# Info Gain Attribute Evaluation
#wekaInfoGainAE;	wekaParametrizeFeatureRankingEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.InfoGainAttributeEval',fen) -> getWekaInfoGainAEConfig0(oList)
# -M, -B optional
wekaInfoGainAEOptsMissingMerge				; getWekaInfoGainAEConfig0(o);	o; ; addOptParam(o, '-M') -> getWekaInfoGainAEConfig1(o)
wekaInfoGainAEOptsBinarizeNumericAttributes	; getWekaInfoGainAEConfig1(o);	o; ; addOptParam(o, '-B')

# OneR Attribute Evaluation
#wekaOneRAE;	wekaParametrizeFeatureRankingEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.OneRAttributeEval',fen) -> getWekaOneRAEConfig0(oList)
# -D optional
wekaOneRAEOptsEvalUsingTrainingData	; getWekaOneRAEConfig0(o);	o; ; addOptParam(o, '-D') -> getWekaOneRAEConfig1(o)
# -F <int> mandatory
wekaOneRAEOptsFolds					; getWekaOneRAEConfig1(o);	o,int; OneRAEFolds(int) ; addMandatValuedParam(o, '-F', int) -> getWekaOneRAEConfig2(o)
# -B <int> mandatory
wekaOneRAEOptsMinimumBucketSize		; getWekaOneRAEConfig2(o);	o,int; OneRAEMinimumBucketSize(int) ; addMandatValuedParam(o, '-B', int) -> getWekaOneRAEConfig3(o)
# -S 1 mandatory
wekaOneRAEOptsSeed					; getWekaOneRAEConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1')

# Principal Component Analysis
#wekaPCA;	wekaParametrizeFeatureRankingEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.PrincipalComponents',fen) -> getWekaPCAConfig0(oList)
# -C, -O optional
wekaPCAOptsCenterData				; getWekaPCAConfig0(o);	o; ; addOptParam(o, '-C') -> getWekaPCAConfig1(o)
wekaPCAOptsTransformBackToOriginal	; getWekaPCAConfig1(o);	o; ; addOptParam(o, '-O') -> getWekaPCAConfig2(o)
# -R <float> mandatory
wekaPCAOptsVarianceCovered			; getWekaPCAConfig2(o);	o,float; PCAVarianceCovered(float) ; addMandatValuedParam(o, '-R', float) -> getWekaPCAConfig3(o)
# -A <int> mandatory
wekaPCAOptsMaximumAttributeNames	; getWekaPCAConfig3(o);	o; ; addMandatValuedParam(o, '-A', '-1')
wekaPCAOptsMaximumAttributeNames	; getWekaPCAConfig3(o);	o,int; PCAMaximumAttributeNames(int) ; addMandatValuedParam(o, '-A', int)

# ReliefF Attribute Evaluation
#wekaReliefF;	wekaParametrizeFeatureRankingEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.ReliefFAttributeEval',fen) -> getWekaReliefFAEConfig0(oList)
# -W optional
wekaReliefFAEOptsWeightByDistance			; getWekaReliefFAEConfig0(o);	o; ; addOptParam(o, '-W') -> getWekaReliefFAEConfig1(o)
# -K <int> mandatory
wekaReliefFAEOptsNumNeighbours	; getWekaReliefFAEConfig1(o);	o,int; ReliefFAENumNeighbours(int) ; addMandatValuedParam(o, '-K', int) -> getWekaReliefFAEConfig2(o)
# -A <int> mandatory, only if -W not used
wekaReliefFOptsSigma1	; getWekaReliefFAEConfig2(o);	o; in(o,'-W') ; noop
wekaReliefFOptsSigma2	; getWekaReliefFAEConfig2(o);	o,int; notin(o,'-W') & ReliefFAESigma(int) ; addMandatValuedParam(o, '-A', int)

# Symmetric Uncertainty Attribute Evaluation
#wekaSymmUncertAE;	wekaParametrizeFeatureRankingEvaluation(fen,oList); fen,oList; ; assignTo('weka.attributeSelection.SymmetricalUncertAttributeEval',fen) -> getWekaSymmUncertAEConfig0(oList)
# -M optional
wekaSymmUncertAEOptsMissingMerge				; getWekaSymmUncertAEConfig0(o);	o; ; addOptParam(o, '-M')


### CLASSIFIER CONSTRUCTION ###

# Weka General Method (single vs. meta vs. ensemble)
wekaBaseClassifier; 		wekaCreateClassifier(c); c; ; wekaCreateBaseClassifier(c)
#wekaMetaClassifier; 		wekaCreateClassifier(c); c; ; wekaCreateMetaClassifier(c)
#wekaEnsembleClassifier;		wekaCreateClassifier(c); c; ; wekaCreateEnsembleClassifier(c)


### BASE CLASSIFIERS ###

# Bayes Network
#wekaBN;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.bayes.BayesNet:__construct(c) -> getOptionList(oList) -> getWekaBNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.bayes.BayesNet:setOptions(c,oArray)
#wekaBN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.bayes.BayesNet',cn) -> getWekaBNConfig0(oList)
# -D optional
wekaBNOptsUseADTree			; getWekaBNConfig0(o);	o; ; addOptParam(o, '-D') -> getWekaBNConfig1(o)
# -Q <proc> mandatory
wekaBNOptsSetLocalSearch	; getWekaBNConfig1(o);	o,proc; BNLocalSearch(proc) ; addMandatValuedParam(o, '-Q', proc)

# Naive Bayes
#wekaNB;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.bayes.NaiveBayes:__construct(c) -> getOptionList(oList) -> getWekaNBConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.bayes.NaiveBayes:setOptions(c,oArray)
#wekaNB;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.bayes.NaiveBayes',cn) -> getWekaNBConfig0(oList)
# -D, -K optional, -D or -K, not both
wekaNBOptsUseKernelEst		; getWekaNBConfig0(o);	o; ; addOptParam(o, '-D') -> getWekaNBConfig1(o)
wekaNBOptsUseSupervisedDisc	; getWekaNBConfig1(o);	o; in(o,'-D') ; noop
wekaNBOptsUseSupervisedDisc	; getWekaNBConfig1(o);	o; notin(o,'-D') ; addOptParam(o, '-K')

# Naive Bayes Multinomial
#wekaNBMN;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.bayes.NaiveBayesMultinomial:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.bayes.NaiveBayesMultinomial:setOptions(c,oArray)
#wekaNBMN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.bayes.NaiveBayesMultinomial',cn)
# No parameter

# Gaussian Processess
#wekaGP;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.functions.GaussianProcesses:__construct(c) -> getOptionList(oList) -> getWekaGPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.GaussianProcesses:setOptions(c,oArray)
#wekaGP;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.GaussianProcesses',cn) -> getWekaGPConfig0(oList)
# -L <float>, -N <int> mandatory
wekaGPOptsTolerance		; getWekaGPConfig0(o);	o,float; GPTolerance(float) ; addMandatValuedParam(o, '-L', float) -> getWekaGPConfig1(o)
wekaGPOptsFilterType	; getWekaGPConfig1(o);	o,int; GPFilterType(int) ; addMandatValuedParam(o, '-N', int) -> getWekaGPConfig2(o)
# -K <class> mandatory
wekaGPOptsKernel		; getWekaGPConfig2(o);	o,name,oLocal,param; Kernel(name) ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaGPLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-K', param)
# Kernel weka.classifiers.functions.supportVector.NormalizedPolyKernel
# -E <float> mandatory
wekaGPOptsKernelNpolyE	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') & PolyKernelExponent(float) ; addMandatValuedParam(o, '-E', float) -> getWekaGPLocalConfig1(o)
# -L optional
wekaGPOptsKernelNpolyL	; getWekaGPLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.PolyKernel
# -E <float> mandatory
wekaGPOptsKernelPolyE	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.PolyKernel') & PolyKernelExponent(float) ; addMandatValuedParam(o, '-E', float) -> getWekaGPLocalConfig1(o)
# -L optional
wekaGPOptsKernelPolyL	; getWekaGPLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.PolyKernel') ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.Puk
# -S <float>, -O <float> mandatory
wekaGPOptsKernelPukS	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelSigma(float) ; addMandatValuedParam(o, '-S', float) -> getWekaGPLocalConfig1(o)
wekaGPOptsKernelPukO	; getWekaGPLocalConfig1(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelOmega(float) ; addMandatValuedParam(o, '-O', float)
# Kernel weka.classifiers.functions.supportVector.RBFKernel
# -G <float> mandatory
wekaGPOptsKernelRBFS	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.RBFKernel') & RBFKernelGamma(float) ; addMandatValuedParam(o, '-G', float)

# Linear Regression
#wekaLinearR;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.functions.LinearRegression:__construct(c) -> getOptionList(oList) -> getWekaLinearRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.LinearRegression:setOptions(c,oArray)
#wekaLinearR;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.LinearRegression',cn) -> getWekaLinearRConfig0(oList)
# -C optional
wekaLinearROptsCollinAttr		; getWekaLinearRConfig0(o);	o; ; addOptParam(o, '-C') -> getWekaLinearRConfig1(o)
# -R <float>, -S <type> mandatory
wekaLinearROptsRidge			; getWekaLinearRConfig1(o);	o,float; LinearRRidge(float) ; addMandatValuedParam(o, '-R', float) -> getWekaLinearRConfig2(o)
wekaLinearROptsAttrSel			; getWekaLinearRConfig2(o);	o,type; LinearRAttrSel(type) ; addMandatValuedParam(o, '-S', type)

# Logistic Regression
#wekaLR;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.functions.Logistic:__construct(c) -> getOptionList(oList) -> getWekaLogisticRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.Logistic:setOptions(c,oArray)
#wekaLR;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.Logistic',cn) -> getWekaLogisticRConfig0(oList)
# -R <float> mandatory
wekaLogisticROptsRidge			; getWekaLogisticRConfig0(o);	o,float; LogisticRRidge(float) ; addMandatValuedParam(o, '-R', float)

# Neural Networks
#wekaNN;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.functions.MultilayerPerceptron:__construct(c) -> getOptionList(oList) -> getWekaNNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.MultilayerPerceptron:setOptions(c,oArray)
#wekaNN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.MultilayerPerceptron',cn) -> getWekaNNConfig0(oList)
# -B, -C, -D, -R optional
wekaNNOptsN2BFilter		; getWekaNNConfig0(o);	o; ; addOptParam(o, '-B') -> getWekaNNConfig1(o)
wekaNNOptsNormNumClass	; getWekaNNConfig1(o);	o; ; addOptParam(o, '-C') -> getWekaNNConfig2(o)
wekaNNOptsDecay			; getWekaNNConfig2(o);	o; ; addOptParam(o, '-D') -> getWekaNNConfig3(o)
wekaNNOptsReset			; getWekaNNConfig3(o);	o; ; addOptParam(o, '-R') -> getWekaNNConfig4(o)
# -H <type>, -L <float>, -M <float>, -S <1> mandatory
wekaNNOptsHiddenLayers	; getWekaNNConfig4(o);	o,type; NNHiddenLayer(type) ; addMandatValuedParam(o, '-H', type) -> getWekaNNConfig5(o)
wekaNNOptsLearningRate	; getWekaNNConfig5(o);	o,float; NNLearningRate(float) ; addMandatValuedParam(o, '-L', float) -> getWekaNNConfig6(o)
wekaNNOptsMomentum		; getWekaNNConfig6(o);	o,float; NNMomentum(float) ; addMandatValuedParam(o, '-M', float) -> getWekaNNConfig7(o)
wekaNNOptsSeed			; getWekaNNConfig7(o);	o; ; addMandatValuedParam(o, '-S', '1')

# SGD
#wekaSGDs;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.SGD:__construct(c) -> getOptionList(oList) -> getWekaSGDConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SGD:setOptions(c,oArray)
#wekaSGDs;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.SGD',cn) -> getWekaSGDConfig0(oList)
# -M, -N optional
wekaSGDOptsReplaceMiss	; getWekaSGDConfig0(o);	o; ; addOptParam(o, '-M') -> getWekaSGDConfig1(o)
wekaSGDOptsNormalize	; getWekaSGDConfig1(o);	o; ; addOptParam(o, '-N') -> getWekaSGDConfig2(o)
# -F <type>, -L <float>, -R <float> mandatory
wekaSGDOptsLossFunc		; getWekaSGDConfig2(o);	o,type; SGDLossFunction(type) ; addMandatValuedParam(o, '-F', type) -> getWekaSGDConfig3(o)
wekaSGDOptsLearningRate	; getWekaSGDConfig3(o);	o,float; SGDLearningRate(float) ; addMandatValuedParam(o, '-L', float) -> getWekaSGDConfig4(o)
wekaSGDOptsLambda		; getWekaSGDConfig4(o);	o,float; SGDLambda(float) ; addMandatValuedParam(o, '-R', float)

# SVM
####### wekaSVMs;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.LibSVM:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.LibSVM:setOptions(c,oArray)
####### wekaSVMs;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.LibSVM',cn)
# TODO

# Simple Linear Regression
#wekaSimpleLinearReg; wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.functions.SimpleLinearRegression:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SimpleLinearRegression:setOptions(c,oArray)
#wekaSimpleLinearReg; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.SimpleLinearRegression',cn)
# No parameters

# Simple Logistic Regression
#wekaSimpleLogisticReg;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.SimpleLogistic:__construct(c) -> getOptionList(oList) -> getWekaSimpleLogRegConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SimpleLogistic:setOptions(c,oArray)
#wekaSimpleLogisticReg;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.SimpleLogistic',cn) -> getWekaSimpleLogRegConfig0(oList)
# -A, -S optional
wekaSimpleLogRegOptsAIC			; getWekaSimpleLogRegConfig0(o);	o; ; addOptParam(o, '-A') -> getWekaSimpleLogRegConfig1(o)
wekaSimpleLogRegOptsCrossVal	; getWekaSimpleLogRegConfig1(o);	o; ; addOptParam(o, '-S') -> getWekaSimpleLogRegConfig2(o)
# -W <float> mandatory, value 0 for unused
wekaSimpleLogRegOptsWeightTrim			; getWekaSimpleLogRegConfig2(o);	o; ; addMandatValuedParam(o, '-W', '0')
wekaSimpleLogRegOptsWeightTrim			; getWekaSimpleLogRegConfig2(o);	o,float; SLROptsWeightTrim(float) ; addMandatValuedParam(o, '-W', float)

# SMO
#wekaSMO;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.SMO:__construct(c) -> getOptionList(oList) -> getWekaSMOConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SMO:setOptions(c,oArray)
#wekaSMO;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.SMO',cn) -> getWekaSMOConfig0(oList)
# -C <float>, -N <int> mandatory
wekaSMOOptsComplexity	; getWekaSMOConfig0(o);	o,float; SMOComplexity(float) ; addMandatValuedParam(o, '-C', float) -> getWekaSMOConfig1(o)
wekaSMOOptsFilter		; getWekaSMOConfig1(o);	o,int; SMOFilterType(int) ; addMandatValuedParam(o, '-N', int) -> getWekaSMOConfig2(o)
# -M optional
wekaSMOBuildCalibrationModels	; getWekaSMOConfig2(o);	o; ; addOptParam(o, '-M') -> getWekaSMOConfig3(o)
# -K <class> mandatory
wekaSMOOptsKernel		; getWekaSMOConfig3(o);	o,name,oLocal,param; Kernel(name) ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaSMOLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-K', param)
# Kernel weka.classifiers.functions.supportVector.NormalizedPolyKernel
# -E <float> mandatory
wekaSMOOptsKernelNpolyE	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') & PolyKernelExponent(float) ; addMandatValuedParam(o, '-E', float) -> getWekaSMOLocalConfig1(o)
# -L optional
wekaSMOOptsKernelNpolyL	; getWekaSMOLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.PolyKernel
# -E <float> mandatory
wekaSMOOptsKernelPolyE	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.PolyKernel') & PolyKernelExponent(float) ; addMandatValuedParam(o, '-E', float) -> getWekaSMOLocalConfig1(o)
# -L optional
wekaSMOOptsKernelPolyL	; getWekaSMOLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.PolyKernel') ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.Puk
# -S <float>, -O <float> mandatory
wekaSMOOptsKernelPukS	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelSigma(float) ; addMandatValuedParam(o, '-S', float) -> getWekaSMOLocalConfig1(o)
wekaSMOOptsKernelPukO	; getWekaSMOLocalConfig1(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelOmega(float) ; addMandatValuedParam(o, '-O', float)
# Kernel weka.classifiers.functions.supportVector.RBFKernel
# -G <float> mandatory
wekaSMOOptsKernelRBFS	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.RBFKernel') & RBFKernelGamma(float) ; addMandatValuedParam(o, '-G', float)

# SMOreg
#wekaSMOreg;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.SMOreg:__construct(c) -> getOptionList(oList) -> getWekaSMOregConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SMOreg:setOptions(c,oArray)
#wekaSMOreg;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.SMOreg',cn) -> getWekaSMOregConfig0(oList)
# -C <float> mandatory
wekaSMOregOptsComplexity	; getWekaSMOregConfig0(o);	o,float; SMOComplexity(float) ; addMandatValuedParam(o, '-C', float) -> getWekaSMOregConfig1(o)
# -N <int> mandatory
wekaSMOregOptsFilter		; getWekaSMOregConfig1(o);	o,int; SMOFilterType(int) ; addMandatValuedParam(o, '-N', int) -> getWekaSMOregConfig2(o)
# -I <class> mandatory
wekaSMOregOptsRegOptimizer	; getWekaSMOregConfig2(o);	o,name,oLocal,param; RegOptimizer(name) ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaSMOregLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-I', param) -> getWekaSMOregConfig3(o)
# RegOptimizer weka.classifiers.functions.supportVector.RegSMOImproved
# -V optional
wekaSMOregUseVariant		; getWekaSMOregLocalConfig0(o); o; in(o,'weka.classifiers.functions.supportVector.RegSMOImproved') ; addOptParam(o, '-V')
# -K <class> mandatory
wekaSMOregOptsKernel		; getWekaSMOregConfig3(o);	o,name,oLocal,param; Kernel(name) ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaSMOregLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-K', param)
# Kernel weka.classifiers.functions.supportVector.NormalizedPolyKernel
# -E <float> mandatory
wekaSMOregOptsKernelNpolyE	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') & PolyKernelExponent(float) ; addMandatValuedParam(o, '-E', float) -> getWekaSMOregLocalConfig1(o)
# -L optional
wekaSMOregOptsKernelNpolyL	; getWekaSMOregLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.PolyKernel
# -E <float> mandatory
wekaSMOregOptsKernelPolyE	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.PolyKernel') & PolyKernelExponent(float) ; addMandatValuedParam(o, '-E', float) -> getWekaSMOregLocalConfig1(o)
# -L optional
wekaSMOregOptsKernelPolyL	; getWekaSMOregLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.PolyKernel') ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.Puk
# -S <float>, -O <float> mandatory
wekaSMOregOptsKernelPukS	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelSigma(float) ; addMandatValuedParam(o, '-S', float) -> getWekaSMOregLocalConfig1(o)
wekaSMOregOptsKernelPukO	; getWekaSMOregLocalConfig1(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelOmega(float) ; addMandatValuedParam(o, '-O', float)
# Kernel weka.classifiers.functions.supportVector.RBFKernel
# -G <float> mandatory
wekaSMOregOptsKernelRBFS	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.RBFKernel') & RBFKernelGamma(float) ; addMandatValuedParam(o, '-G', float)

# Voted Perceptrons
#wekaVotedPerceptrons;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.VotedPerceptron:__construct(c) -> getOptionList(oList) -> getWekaVPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.VotedPerceptron:setOptions(c,oArray)
#wekaVotedPerceptrons;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.VotedPerceptron',cn) -> getWekaVPConfig0(oList)
# -E <float>, -I <int>, -M <int> mandatory
wekaVPOptsExponent		; getWekaVPConfig0(o);	o,float; VPExponent(float) ; addMandatValuedParam(o, '-E', float) -> getWekaVPConfig1(o)
wekaVPOptsIterations	; getWekaVPConfig1(o);	o,int; VPIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaVPConfig2(o)
wekaVPOptsMaxK			; getWekaVPConfig2(o);	o,int; VPMaxK(int) ; addMandatValuedParam(o, '-M', int)

# KNN
#wekaKNN;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.lazy.IBk:__construct(c) -> getOptionList(oList) -> getWekaKNNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.IBk:setOptions(c,oArray)
#wekaKNN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.lazy.IBk',cn) -> getWekaKNNConfig0(oList)
# -E, -X. -I, -F optional, -I or -F, not both
wekaKNNOptsMeanSquared			; getWekaKNNConfig0(o);	o; ; addOptParam(o, '-E') -> getWekaKNNConfig1(o)
wekaKNNOptsCrossValidate		; getWekaKNNConfig1(o);	o; ; addOptParam(o, '-X') -> getWekaKNNConfig2(o)
wekaKNNOptsDistanceWeighingA	; getWekaKNNConfig2(o);	o; ; addOptParam(o, '-I') -> getWekaKNNConfig3(o)
wekaKNNOptsDistanceWeighingB1	; getWekaKNNConfig3(o);	o; in(o,'-I') ; noop -> getWekaKNNConfig4(o)
wekaKNNOptsDistanceWeighingA2	; getWekaKNNConfig3(o);	o; notin(o,'-I') ; addOptParam(o, '-F') -> getWekaKNNConfig4(o)
# -K <int> mandatory
wekaKNNOptsKNN					; getWekaKNNConfig4(o);	o,int; KNNKNN(int) ; addMandatValuedParam(o, '-K', int)

# KStar
#wekaKStar;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.lazy.KStar:__construct(c) -> getOptionList(oList) -> getWekaKStarConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.KStar:setOptions(c,oArray)
#wekaKStar;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.lazy.KStar',cn) -> getWekaKStarConfig0(oList)
# -E optional
wekaKStarOptsEntropicAutoBlend	; getWekaKStarConfig0(o);	o; ; addOptParam(o, '-E') -> getWekaKStarConfig1(o)
# -B <float>, -M <type> mandatory
wekaKStarOptsGlobalBlend		; getWekaKStarConfig1(o);	o,float; KStarGlobalBlend(float) ; addMandatValuedParam(o, '-B', float) -> getWekaKStarConfig2(o)
wekaKStarOptsMissingMode		; getWekaKStarConfig2(o);	o,type; KStarMissingMode(type) ; addMandatValuedParam(o, '-M', type)

# Decision Tables
#wekaDecTable;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.DecisionTable:__construct(c) -> getOptionList(oList) -> getWekaDecTableConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.DecisionTable:setOptions(c,oArray)
#wekaDecTable;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.rules.DecisionTable',cn) -> getWekaDecTableConfig0(oList)
# -I optional
wekaDecTableOptsUseIBk		; getWekaDecTableConfig0(o);	o; ; addOptParam(o, '-I') -> getWekaDecTableConfig1(o)
# -E <type>, -S <class>, -X <type> mandatory
wekaDecTableOptsEvalMeasure	; getWekaDecTableConfig1(o);	o,type; DecTableEvalMeasure(type) ; addMandatValuedParam(o, '-E', type) -> getWekaDecTableConfig2(o)
wekaDecTableOptsSearch		; getWekaDecTableConfig2(o);	o,class; DecTableSearch(class) ; addMandatValuedParam(o, '-S', class) -> getWekaDecTableConfig3(o)
wekaDecTableOptsCrossVal	; getWekaDecTableConfig3(o);	o,type; DecTableCrossVal(type) ; addMandatValuedParam(o, '-X', type)

# RIPPER
#wekaRipper;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.JRip:__construct(c) -> getOptionList(oList) -> getWekaRipperConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.JRip:setOptions(c,oArray)
#wekaRipper;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.rules.JRip',cn) -> getWekaRipperConfig0(oList)
# -E, -P optional
wekaRipperOptsCheckErrorRate	; getWekaRipperConfig0(o);	o; ; addOptParam(o, '-E') -> getWekaRipperConfig1(o)
wekaRipperOptsUsePruning		; getWekaRipperConfig1(o);	o; ; addOptParam(o, '-P') -> getWekaRipperConfig2(o)
# -N <float>, -O <int> mandatory
wekaRipperOptsMinNo				; getWekaRipperConfig2(o);	o,float; RipperMinNo(float) ; addMandatValuedParam(o, '-N', float) -> getWekaRipperConfig3(o)
wekaRipperOptsOptimizations		; getWekaRipperConfig3(o);	o,int; RipperOptimizations(int) ; addMandatValuedParam(o, '-O', int)

# M5Rules
#wekaM5Rules; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.M5Rules:__construct(c) -> getOptionList(oList) -> getWekaM5RulesConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.M5Rules:setOptions(c,oArray)
#wekaM5Rules; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.rules.M5Rules',cn) -> getWekaM5RulesConfig0(oList)
# -N, -U, -R optional
wekaM5RulesOptsUnpruned			; getWekaM5RulesConfig0(o);	o; ; addOptParam(o, '-N') -> getWekaM5RulesConfig1(o)
wekaM5RulesOptsUseUnsmoothed	; getWekaM5RulesConfig1(o);	o; ; addOptParam(o, '-U') -> getWekaM5RulesConfig2(o)
wekaM5RulesOptBuildRegressionTree	; getWekaM5RulesConfig2(o);	o; ; addOptParam(o, '-R') -> getWekaM5RulesConfig3(o)
# -M <int> mandatory
wekaM5RulesOptsMinNumInstances	; getWekaM5RulesConfig3(o);	o,int; M5RulesMinNumInstances(int) ; addMandatValuedParam(o, '-M', int)

# OneR
#wekaOneR; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.OneR:__construct(c) -> getOptionList(oList) -> getWekaOneRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.OneR:setOptions(c,oArray)
#wekaOneR; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.rules.OneR',cn) -> getWekaOneRConfig0(oList)
# -B <int> mandatory
wekaOneROptsMinBucketSize	; getWekaOneRConfig0(o);	o,int; OneRMinBucketSize(int) ; addMandatValuedParam(o, '-B', int)

# PART
#wekaPART; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.PART:__construct(c) -> getOptionList(oList) -> getWekaPARTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.PART:setOptions(c,oArray)
#wekaPART; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.rules.PART',cn) -> getWekaPARTConfig0(oList)
# -B, -R optional
wekaPARTOptsBinarySplits			; getWekaPARTConfig0(o);	o; ; addOptParam(o, '-B') -> getWekaPARTConfig1(o)
wekaPARTOptsReducedErrorPruning		; getWekaPARTConfig1(o);	o; ; addOptParam(o, '-R') -> getWekaPARTConfig2(o)
# -M <int>, -N <int> mandatory; IF R THEN N
wekaPARTOptsMinNumObj	; getWekaPARTConfig2(o);	o,int; PARTMinNumObj(int) ; addMandatValuedParam(o, '-M', int) -> getWekaPARTConfig3(o)
wekaPARTOptsNumFoldsN	; getWekaPARTConfig3(o);	o; notin(o,'-R') ; noop
wekaPARTOptsNumFoldsY	; getWekaPARTConfig3(o);	o,int; in(o,'-R') & PARTNumFolds(int) ; addMandatValuedParam(o, '-N', int)

# ZeroR
#wekaZeroR; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.ZeroR:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.ZeroR:setOptions(c,oArray)
#wekaZeroR; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.rules.ZeroR',cn)
# No parameters.

# Decision Stump
#wekaDecisionStump; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.DecisionStump:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.DecisionStump:setOptions(c,oArray)
#wekaDecisionStump; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.DecisionStump',cn)
# No parameters.

# Decision Trees C4.5
#wekaDT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.J48:__construct(c) -> getOptionList(oList) -> getWekaDTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.J48:setOptions(c,oArray)
#wekaDT; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.J48',cn) -> getWekaDTConfig0(oList)
# -A, -B, -J, -O optional
wekaDTOptsUseLaplace		; getWekaDTConfig0(o);	o; ; addOptParam(o, '-A') -> getWekaDTConfig1(o)
wekaDTOptsBinarySplits		; getWekaDTConfig1(o);	o; ; addOptParam(o, '-B') -> getWekaDTConfig2(o)
wekaDTOptsUseMDLCorrection	; getWekaDTConfig2(o);	o; ; addOptParam(o, '-J') -> getWekaDTConfig3(o)
wekaDTOptsCollapseTree		; getWekaDTConfig3(o);	o; ; addOptParam(o, '-O') -> getWekaDTConfig4(o)
wekaDTOptsSubtreeRaising	; getWekaDTConfig4(o);	o; ; addOptParam(o, '-S') -> getWekaDTConfig5(o)
# -S, -U optional, not both -S and -U set
wekaDTOptsErrorUnpruned		; getWekaDTConfig5(o);	o; in(o,'-S') ; noop -> getWekaDTConfig6(o)
wekaDTOptsErrorUnpruned		; getWekaDTConfig5(o);	o; notin(o,'-S') ; addOptParam(o, '-U') -> getWekaDTConfig6(o)
# -C <int> mandatory, only if -U not present
wekaDTOptsConfidenceFactor	; getWekaDTConfig6(o);	o; in(o,'-U') ; noop -> getWekaDTConfig7(o)
wekaDTOptsConfidenceFactor	; getWekaDTConfig6(o);	o,float; notin(o,'-U') & DTConfidenceFactor(float) ; addMandatValuedParam(o, '-C', float) -> getWekaDTConfig7(o)
# -M <int> mandatory
wekaDTOptsMinNumObj	; getWekaDTConfig7(o);	o,int; DTMinNumObj(int) ; addMandatValuedParam(o, '-M', int)

# Logistic Model Tree
#wekaLMT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.LMT:__construct(c) -> getOptionList(oList) -> getWekaLMTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.LMT:setOptions(c,oArray)
#wekaLMT; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.LMT',cn) -> getWekaLMTConfig0(oList)
# -A, -B, -C, -R, -P optional
wekaLMTOptsUseAIC			; getWekaLMTConfig0(o);	o; ; addOptParam(o, '-A') -> getWekaLMTConfig1(o)
wekaLMTOptsConvertNominals	; getWekaLMTConfig1(o);	o; ; addOptParam(o, '-B') -> getWekaLMTConfig2(o)
wekaLMTOptsFastRegression	; getWekaLMTConfig2(o);	o; ; addOptParam(o, '-C') -> getWekaLMTConfig3(o)
wekaLMTOptsErrorOnProb		; getWekaLMTConfig3(o);	o; ; addOptParam(o, '-P') -> getWekaLMTConfig4(o)
wekaLMTOptsSplitOnResiduals	; getWekaLMTConfig4(o);	o; ; addOptParam(o, '-R') -> getWekaLMTConfig5(o)
# -M <int> mandatory
wekaLMTOptsMinNumInstances	; getWekaLMTConfig5(o);	o,int; LMTMinNumInstances(int) ; addMandatValuedParam(o, '-M', int) -> getWekaLMTConfig6(o)
# -W <float> mandatory, value 0 for unused
wekaLMTOptsWeightTrimBeta	; getWekaLMTConfig6(o);	o; ; addMandatValuedParam(o, '-W', '0')
wekaLMTOptsWeightTrimBeta	; getWekaLMTConfig6(o);	o,float; LMTWeightTrimBeta(float) ; addMandatValuedParam(o, '-W', float)


####### Problem in LMT: single remaining OPEN node sometimes


# M5 Tree
#wekaM5P; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.M5P:__construct(c) -> getOptionList(oList) -> getWekaM5PConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.M5P:setOptions(c,oArray)
#wekaM5P; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.M5P',cn) -> getWekaM5PConfig0(oList)
# -N, -U, -R optional
wekaM5POptsUnpruned			; getWekaM5PConfig0(o);	o; ; addOptParam(o, '-N') -> getWekaM5PConfig1(o)
wekaM5POptsUseUnsmoothed	; getWekaM5PConfig1(o);	o; ; addOptParam(o, '-U') -> getWekaM5PConfig2(o)
wekaM5POptsBuildRegTree		; getWekaM5PConfig2(o);	o; ; addOptParam(o, '-R') -> getWekaM5PConfig3(o)
# -M <int> mandatory
wekaM5POptsMinNumInstances	; getWekaM5PConfig3(o);	o,int; M5PMinNumInstances(int) ; addMandatValuedParam(o, '-M', int)

# Random Forest
wekaRF; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.RandomForest:__construct(c) -> getOptionList(oList) -> getWekaRFConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomForest:setOptions(c,oArray)
wekaRF; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.RandomForest',cn) -> getWekaRFConfig0(oList)
# -I <int> mandatory
wekaRFOptsNumIterations	; getWekaRFConfig0(o);	o,int; RFNumIterations(int) ; addMandatValuedParam(o, '-K', int) -> getWekaRFConfig1(o)
# -K <int> mandatory, value 0 for unused
wekaRFOptsNumFeatures	; getWekaRFConfig1(o);	o; ; addMandatValuedParam(o, '-M', '0') -> getWekaRFConfig2(o)
wekaRFOptsNumFeatures	; getWekaRFConfig1(o);	o,int; RFNumFeatures(int) ; addMandatValuedParam(o, '-M', int) -> getWekaRFConfig2(o)
# -depth <int> mandatory, value 0 for unused
wekaRFOptsMaxDepth		; getWekaRFConfig2(o);	o; ; addMandatValuedParam(o, '-depth', '0')
wekaRFOptsMaxDepth		; getWekaRFConfig2(o);	o,int; RFMaxDepth(int) ; addMandatValuedParam(o, '-depth', int)

# Random Tree
#wekaRT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.RandomTree:__construct(c) -> getOptionList(oList) -> getWekaRTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomTree:setOptions(c,oArray)
#wekaRT; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.RandomTree',cn) -> getWekaRTConfig0(oList)
# -U optional
wekaRTOptsAllowUnclass	; getWekaRTConfig0(o);	o; ; addOptParam(o, '-U') -> getWekaRTConfig1(o)
# -K <int> mandatory, value 0 for unused
wekaRTOptsKValue		; getWekaRTConfig1(o);	o; ; addMandatValuedParam(o, '-K', '0') -> getWekaRTConfig2(o)
wekaRTOptsKValue		; getWekaRTConfig1(o);	o,int; RTKValue(int) ; addMandatValuedParam(o, '-K', int) -> getWekaRTConfig2(o)
# -M <int> mandatory
wekaRTOptsMinNum		; getWekaRTConfig2(o);	o,int; RTMinNum(int) ; addMandatValuedParam(o, '-M', int) -> getWekaRTConfig3(o)
# -N <int> mandatory, value 0 for unused
wekaRTOptsNumFolds	; getWekaRTConfig3(o);	o; ; addMandatValuedParam(o, '-N', '0') -> getWekaRTConfig4(o)
wekaRTOptsNumFolds	; getWekaRTConfig3(o);	o,int; RTNumFolds(int) ; addMandatValuedParam(o, '-N', int) -> getWekaRTConfig4(o)
# -depth <int> mandatory, value 0 for unused
wekaRTOptsMaxDepth	; getWekaRTConfig4(o);	o; ; addMandatValuedParam(o, '-depth', '0')
wekaRTOptsMaxDepth	; getWekaRTConfig4(o);	o,int; RTMaxDepth(int) ; addMandatValuedParam(o, '-depth', int)

# REP Tree
#wekaREP; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.REPTree:__construct(c) -> getOptionList(oList) -> getWekaREPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.REPTree:setOptions(c,oArray)
#wekaREP; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.REPTree',cn) -> getWekaREPConfig0(oList)
# -P optional
wekaREPOptsPruning			; getWekaREPConfig0(o);	o; ; addOptParam(o, '-P') -> getWekaREPConfig1(o)
# -L <int> mandatory, value -1 for unused
wekaREPOptsMaxDepth		; getWekaREPConfig1(o);	o; ; addMandatValuedParam(o, '-L', '-1') -> getWekaREPConfig2(o)
wekaREPOptsMaxDepth		; getWekaREPConfig1(o);	o,int; REPMaxDepth(int) ; addMandatValuedParam(o, '-L', int) -> getWekaREPConfig2(o)
# -M <int>, -V <float> mandatory
wekaREPOptsMinNum		; getWekaREPConfig2(o);	o,int; REPMinNum(int) ; addMandatValuedParam(o, '-M', int) -> getWekaREPConfig3(o)
wekaREPOptsMinVariance	; getWekaREPConfig3(o);	o,float; REPMinVariance(float) ; addMandatValuedParam(o, '-V', float)


# Nested Dichotomies
#wekaNDs;	wekaCreateBaseClassifier(c); c; ; wekaCreateNDClassifier(c)
rpnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.RandomPairND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.RandomPairND:setOptions(c,oArray)
cbnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.ClassBalancedND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.ClassBalancedND:setOptions(c,oArray)
dnbnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:setOptions(c,oArray)
fcnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:setOptions(c,oArray)
nd;		wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.ND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.ND:setOptions(c,oArray)
wekaNDOptsClose				; getWekaNDConfig(o);	o; ; noop
wekaNDOptsSetBaseLearner	; getWekaNDConfig(o);	o; ; addWekaBaseLearner(o) -> getWekaNDConfig(o)


### META CLASSIFIERS ###

# Locally Weighted Learning
#wekaLWL;	wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.lazy.LWL:__construct(c) -> getOptionList(oList) -> getWekaLWLConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.LWL:setOptions(c,oArray)
# -A <class> mandatory
wekaLWLOptsNearestNeighbourSearch	; getWekaLWLConfig0(o);	o,name,oLocal,param; LWLNearestNeighbourSearch(name) ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-A', param) -> getWekaLWLConfig1(o)
# -K <int> optional
wekaLWLOptsKNN						; getWekaLWLConfig1(o);	o,int; LWLKNN(int) ; addOptValuedParam(o, '-K', int) -> getWekaLWLConfig2(o)
# -U <int> optional, -K or -U has to be used
wekaLWLOptsWeighingKernel			; getWekaLWLConfig2(o);	o,int; notin(o,'-K') & LWLWeighingKernel(int) ; addMandatValuedParam(o, '-U', int) -> getWekaLWLConfig3(o)
wekaLWLOptsWeighingKernel			; getWekaLWLConfig2(o);	o,int; in(o,'-K') & LWLWeighingKernel(int) ; addOptValuedParam(o, '-U', int) -> getWekaLWLConfig3(o)
# -W <base> mandatory
wekaLWLOptsBaseClassifier			; getWekaLWLConfig3(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# AdaBoost
#wekaAdaBoost;	wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.AdaBoostM1:__construct(c) -> getOptionList(oList) -> getWekaAdaBoostConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AdaBoostM1:setOptions(c,oArray)
# -Q optional
wekaAdaBoostOptsUseResampling	; getWekaAdaBoostConfig0(o);	o; ; addOptParam(o, '-Q') -> getWekaAdaBoostConfig1(o)
# -I <int> mandatory
wekaAdaBoostOptsNumIterations	; getWekaAdaBoostConfig1(o);	o,int; AdaBoostNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaAdaBoostConfig2(o)
# -P <int> mandatory, value 100 for unused
wekaAdaBoostOptsWeightThreshold	; getWekaAdaBoostConfig2(o);	o; ; addMandatValuedParam(o, '-P', '100') -> getWekaAdaBoostConfig3(o)
wekaAdaBoostOptsWeightThreshold	; getWekaAdaBoostConfig2(o);	o,int; AdaBoostWeightThreshold(int) ; addMandatValuedParam(o, '-P', int) -> getWekaAdaBoostConfig3(o)
# -S 1  mandatory
wekaAdaBoostOptsSeed			; getWekaAdaBoostConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaAdaBoostConfig4(o)
# -W <base> mandatory
wekaAdaBoostOptsBaseClassifier	; getWekaAdaBoostConfig4(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# MultiBoost
#wekaMultiBoost; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.MultiBoostAB:__construct(c) -> getOptionList(oList) -> getWekaMultiBoostConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.MultiBoostAB:setOptions(c,oArray)
# -W <base> mandatory
wekaMultiBoostOptsBaseClassifier	; getWekaMultiBoostConfig0(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Additive Regression
#wekaAddReg; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.AdditiveRegression:__construct(c) -> getOptionList(oList) -> getWekaAddRegConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AdditiveRegression:setOptions(c,oArray)
# -I <int>  mandatory
wekaAddRegOptsNumIterations	; getWekaAddRegConfig0(o);	o,int; AddRegNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaAddRegConfig1(o)
# -S <float> mandatory, value 1 for unused
wekaAddRegOptsShrinkage	; getWekaAddRegConfig1(o);	o;  ; addMandatValuedParam(o, '-S', '1') -> getWekaAddRegConfig2(o)
wekaAddRegOptsShrinkage	; getWekaAddRegConfig1(o);	o,float; AddRegShrinkage(float) ; addMandatValuedParam(o, '-S', float) -> getWekaAddRegConfig2(o)
# -W <base> mandatory
wekaAddRegOptsBaseClassifier	; getWekaAddRegConfig2(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Attribute Selected
#wekaAttributeSelected; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.AttributeSelectedClassifier:__construct(c) -> getOptionList(oList) -> getWekaAttributeSelectedConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AttributeSelectedClassifier:setOptions(c,oArray)
# -S <class>, -E <class>  mandatory
wekaAddRegOptsSearchAndEval	; getWekaAttributeSelectedConfig0(o);	o,oLocal; ; getOptionList(oLocal) -> getWekaASConfig0(oLocal) -> appendOptions(o, oLocal) -> getWekaAttributeSelectedConfig1(o)
# -W <base> mandatory
wekaAttributeSelectedOptsBaseClassifier	; getWekaAttributeSelectedConfig1(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Bagging
#wekaBagging;	wekaCreateMetaClassifier(c); c, oList, oArray; ; weka.classifiers.meta.Bagging:__construct(c) -> getOptionList(oList) -> getWekaBaggingConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.Bagging:setOptions(c,oArray)
# -O optional
wekaBaggingOptsCalcOutOfBag		; getWekaBaggingConfig0(o);	o; ; addOptParam(o, '-O') -> getWekaBaggingConfig1(o)
# -I <int> mandatory
wekaBaggingOptsNumIterations	; getWekaBaggingConfig1(o);	o,int; BaggingNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaBaggingConfig2(o)
# -P <int> mandatory
wekaBaggingOptsBagSizePercent	; getWekaBaggingConfig2(o);	o; in(o,'-O') ; addMandatValuedParam(o, '-P', '100') -> getWekaBaggingConfig3(o)
wekaBaggingOptsBagSizePercent	; getWekaBaggingConfig2(o);	o,int; notin(o,'-O') & BaggingBagSizePercent(int) ; addMandatValuedParam(o, '-P', int) -> getWekaBaggingConfig3(o)
# -S 1  mandatory
wekaBaggingOptsSeed				; getWekaBaggingConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaBaggingConfig4(o)
# -W <base> mandatory
wekaBaggingOptsBaseClassifier	; getWekaBaggingConfig4(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Classification via Regression
#wekaClassificationViaRegression; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.ClassificationViaRegression:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.ClassificationViaRegression:setOptions(c,oArray)
# -W <base> mandatory
wekaCVROptsBaseClassifier	; getWekaMCCConfig3(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Logit Boost
#wekaLogitBoost; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.LogitBoost:__construct(c) -> getOptionList(oList) -> getWekaLogitBoostConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.LogitBoost:setOptions(c,oArray)
# -Q optional
wekaLogitBoostOptsUseResampling			; getWekaLogitBoostConfig0(o);	o; ; addOptParam(o, '-Q') -> getWekaLogitBoostConfig1(o)
# -I <int> mandatory
wekaLogitBoostOptsNumIterations			; getWekaLogitBoostConfig1(o);	o,int; LogitBoostNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaLogitBoostConfig2(o)
# -H <float> mandatory, value 1 for unused
wekaLogitBoostOptsShrinkage				; getWekaLogitBoostConfig2(o);	o;  ; addMandatValuedParam(o, '-H', '1') -> getWekaLogitBoostConfig5(o)
wekaLogitBoostOptsShrinkage				; getWekaLogitBoostConfig2(o);	o,float; LogitBoostShrinkage(float) ; addMandatValuedParam(o, '-H', float) -> getWekaLogitBoostConfig5(o)
# -R <int> mandatory: NOT AVAILABLE IN WEKA 3.8, THEREFORE SKIPPED!!
wekaLogitBoostOptsNumRuns				; getWekaLogitBoostConfig3(o);	o,int; LogitBoostNumRuns(int) ; addMandatValuedParam(o, '-R', int) -> getWekaLogitBoostConfig4(o)
# -F <int> mandatory, value 0 for unused: NOT AVAILABLE IN WEKA 3.8, THEREFORE SKIPPED!!
wekaLogitBoostOptsNumFolds				; getWekaLogitBoostConfig4(o);	o;  ; addMandatValuedParam(o, '-F', '0') -> getWekaLogitBoostConfig5(o)
wekaLogitBoostOptsNumFolds				; getWekaLogitBoostConfig4(o);	o,int; LogitBoostNumFolds(int) ; addMandatValuedParam(o, '-F', int) -> getWekaLogitBoostConfig5(o)
# -P <int> mandatory, value 100 for unused
wekaLogitBoostOptsWeightThreshold		; getWekaLogitBoostConfig5(o);	o; in(o,'-Q') ; noop -> getWekaLogitBoostConfig6(o)
wekaLogitBoostOptsWeightThreshold		; getWekaLogitBoostConfig5(o);	o,int; notin(o,'-Q') & LogitBoostWeightThreshold(int) ; addMandatValuedParam(o, '-P', int) -> getWekaLogitBoostConfig6(o)
# -L 1e50  mandatory
wekaLogitBoostOptsLikelihoodThreshold 	; getWekaLogitBoostConfig6(o);	o; ; addMandatValuedParam(o, '-L', '1e50') -> getWekaLogitBoostConfig7(o)
# -S 1  mandatory
wekaLogitBoostOptsSeed					; getWekaLogitBoostConfig7(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaLogitBoostConfig8(o)
# -W <base> mandatory
wekaLogitBoostOptsBaseClassifier		; getWekaLogitBoostConfig8(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# MultiClass Classifier
#wekaMCC; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.MultiClassClassifier:__construct(c) -> getOptionList(oList) -> getWekaMCCConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.MultiClassClassifier:setOptions(c,oArray)
# -P optional
wekaMCCOptsUsePairwiseCoupling	; getWekaMCCConfig0(o);	o; ; addOptParam(o, '-P') -> getWekaMCCConfig1(o)
# -M <type> mandatory
wekaMCCOptsMethod				; getWekaMCCConfig1(o);	o,type; MCCMethod(type) ; addMandatValuedParam(o, '-M', type) -> getWekaMCCConfig2(o)
# -R <float> mandatory
wekaMCCOptsRandomWidthFactor	; getWekaMCCConfig2(o);	o,float; MCCRandomWidthFactor(float) ; addMandatValuedParam(o, '-R', float) -> getWekaMCCConfig3(o)
# -S 1  mandatory
wekaMCCOptsSeed					; getWekaMCCConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaMCCConfig4(o)
# -W <base> mandatory
wekaMCCOptsBaseClassifier		; getWekaMCCConfig4(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Random Comittee
#wekaLogitBoost; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.LogitBoost:__construct(c) -> getOptionList(oList) -> getWekaLogitBoostConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.LogitBoost:setOptions(c,oArray)
# -I <int>, -S 1  mandatory
wekaRandomComitteeOptsNumIterations		; getWekaRandomComitteeConfig0(o);	o,int; RandomComitteeNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaRandomComitteeConfig1(o)
wekaRandomComitteeOptsSeed				; getWekaRandomComitteeConfig1(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaRandomComitteeConfig2(o)
# -W <base> mandatory
wekaRandomComitteeOptsBaseClassifier	; getWekaRandomComitteeConfig2(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Random Subspace
#wekaRandomSubspace; wekaCreateMetaClassifier(c); c,oList,oArray; ; weka.classifiers.meta.RandomSubSpace:__construct(c) -> getOptionList(oList) -> getWekaRandomSubspaceConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.RandomSubSpace:setOptions(c,oArray)
# -I <int> mandatory
wekaRandomSubspaceOptsNumIterations		; getWekaRandomSubspaceConfig0(o);	o,int; RandomSubspaceNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaRandomSubspaceConfig1(o)
# -P <float> mandatory
wekaRandomSubspaceOptsSubSpaceSize		; getWekaRandomSubspaceConfig1(o);	o,float; RandomSubspaceSubSpaceSizePercent(float) ; addMandatValuedParam(o, '-P', float) -> getWekaRandomSubspaceConfig2(o)
# -S 1  mandatory
wekaRandomSubspaceOptsSeed				; getWekaRandomSubspaceConfig2(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaRandomSubspaceConfig3(o)
# -W <base> mandatory
wekaRandomSubspaceOptsBaseClassifier	; getWekaRandomSubspaceConfig3(o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)


### ENSEMBLE CLASSIFIERS ###

# Voting
#wekaVote;	wekaCreateEnsembleClassifier(c); c,oList,oArray; ; weka.classifiers.meta.Vote:__construct(c) -> getOptionList(oList) -> getWekaVoteConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.Vote:setOptions(c,oArray)
# -R <proc>, -S 1  mandatory
wekaVoteOptsCombinationRule	; getWekaVoteConfig0(o);	o,proc; VoteCombinationRule(proc) ; addMandatValuedParam(o, '-R', proc) -> getWekaVoteConfig1(o)
wekaVoteOptsSeed			; getWekaVoteConfig1(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaVoteConfig2(o)
# -B <base> mandatory
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; getWekaVoteConfig3(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; getWekaVoteConfig4(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; getWekaVoteConfig5(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; getWekaVoteConfig6(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; getWekaVoteConfig7(o)
wekaVoteBaseClassifier	; getWekaVoteConfig3(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig4(o)
wekaVoteBaseClassifier	; getWekaVoteConfig4(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig5(o)
wekaVoteBaseClassifier	; getWekaVoteConfig5(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig6(o)
wekaVoteBaseClassifier	; getWekaVoteConfig6(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig7(o)
wekaVoteBaseClassifier	; getWekaVoteConfig7(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val)

# Stacking
#wekaStacking;	wekaCreateEnsembleClassifier(c); c,oList,oArray; ; weka.classifiers.meta.Stacking:__construct(c) -> getOptionList(oList) -> getWekaStackingConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.Stacking:setOptions(c,oArray)
# -X 10, -S 1  mandatory
wekaStackingOptsNumFolds	; getWekaStackingConfig0(o);	o; ; addMandatValuedParam(o, '-X', '10') -> getWekaStackingConfig1(o)
wekaStackingOptsSeed		; getWekaStackingConfig1(o);	o; ; addMandatValuedParam(o, '-S', '1') -> getWekaStackingConfig2(o)
# -B <base> mandatory
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; getWekaStackingConfig3(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; getWekaStackingConfig4(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; getWekaStackingConfig5(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; getWekaStackingConfig6(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; getWekaStackingConfig7(o)
wekaStackingBaseClassifier	; getWekaStackingConfig3(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig4(o)
wekaStackingBaseClassifier	; getWekaStackingConfig4(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig5(o)
wekaStackingBaseClassifier	; getWekaStackingConfig5(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig6(o)
wekaStackingBaseClassifier	; getWekaStackingConfig6(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig7(o)
wekaStackingBaseClassifier	; getWekaStackingConfig7(o);	o,cnLocal,oLocal,val; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val)


## VALIDATION ##
####### simpleValidation; validate(c,x,f,r,quality); c,x,split,train,test,f,r,e,quality; Classifier(c) & Instances(test); split(x,split) -> retrieveTrain(split,train) -> weka.classifiers.Classifier:buildClassifier(c,train) -> weka.classifiers.evaluation.Evaluation:__construct(train,e) -> retrieveTest(split,test) -> weka.classifiers.evaluation.Evaluation:evaluateModel(e,c,test) -> weka.classifiers.evaluation.Evaluation:pctCorrect(e,quality)
####### crossValidation; validate(c,x,f,r,quality); c,x,f,r,e,quality; Classifier(c) & Instances(x) & Folds(f) & Random(r); weka.classifiers.evaluation.Evaluation:__construct(x,e) -> weka.classifiers.evaluation.Evaluation:crossValidateModel(e, c, x, f, r) -> weka.classifiers.evaluation.Evaluation:pctCorrect(e,quality)


[Rules]
# Clauses
# clauses have two fields, the first describes the params, the second is a set of literals separated by a pipe symbol 
# Example:
# x:Number; !P(x) | Q(x)
# The hierarchical planning system currently does not support knowledge with clauses

# Facts
# put simply literals here (all parameters are interpreted as constants)

Thing(null)
#x:Instances,y:Instances; !Instances(x) | !assigned(x,y) | Instances(y)


### FEATURE SELECTION SEARCHER ###

# Best First direction: Option -D {0, 1, 2}[1]
#### BFDirection(0)
BFDirection(1)
#### BFDirection(2)

# Best First searchTermination: Option -N [2, 10][5]i
BFSearchTermination(2)
#### BFSearchTermination(3)
BFSearchTermination(4)
#### BFSearchTermination(5)
BFSearchTermination(6)
#### BFSearchTermination(7)
BFSearchTermination(8)
#### BFSearchTermination(9)
BFSearchTermination(10)

# Greedy Stepwise numToSelect: Option -N [10,1000][30]il
GSNumToSelect(10)
#### GSNumToSelect(20)
GSNumToSelect(30)
#### GSNumToSelect(62)
GSNumToSelect(125)
#### GSNumToSelect(250)
GSNumToSelect(500)
#### GSNumToSelect(1000)

# Greedy Stepwise treshold: Option -T [0, 20] [1]
#### GSThreshold(0)
GSThreshold(1)
#### GSThreshold(4)
GSThreshold(7)
#### GSThreshold(10)
GSThreshold(13)
#### GSThreshold(16)
GSThreshold(20)

# Ranker treshold: Option -T [0.2,10][1]
#### RankThreshold(0.2)
RankThreshold(1)
#### RankThreshold(2)
RankThreshold(3)
#### RankThreshold(4)
RankThreshold(5)
#### RankThreshold(6)
RankThreshold(7)
#### RankThreshold(8)
RankThreshold(9)
#### RankThreshold(10)


### FEATURE SELECTION EVALUATORS ###

# OneR Attribute Evaluation minimumBucketSize: Option -B [1,64][6]il
#### OneRAEMinimumBucketSize(1)
OneRAEMinimumBucketSize(2)
#### OneRAEMinimumBucketSize(4)
OneRAEMinimumBucketSize(6)
#### OneRAEMinimumBucketSize(8)
OneRAEMinimumBucketSize(16)
#### OneRAEMinimumBucketSize(32)
OneRAEMinimumBucketSize(64)

# OneR Attribute Evaluation folds: Option -F [2,15][10]i
OneRAEFolds(2)
#### OneRAEFolds(4)
OneRAEFolds(6)
#### OneRAEFolds(8)
OneRAEFolds(10)
#### OneRAEFolds(12)
OneRAEFolds(14)
#### OneRAEFolds(15)

# Principal Component Analysis varianceCovered: Option -R [0.5, 1.0][0.95]
PCAVarianceCovered(0.5)
#### PCAVarianceCovered(0.55)
PCAVarianceCovered(0.6)
#### PCAVarianceCovered(0.65)
PCAVarianceCovered(0.7)
#### PCAVarianceCovered(0.75)
PCAVarianceCovered(0.8)
#### PCAVarianceCovered(0.85)
#### PCAVarianceCovered(0.9)
PCAVarianceCovered(0.95)
#### PCAVarianceCovered(1.0)

# Principal Component Analysis maximumAttributeNames: Option -A [1, 1024][32]il
#### PCAMaximumAttributeNames(1)
PCAMaximumAttributeNames(2)
#### PCAMaximumAttributeNames(4)
PCAMaximumAttributeNames(8)
#### PCAMaximumAttributeNames(16)
PCAMaximumAttributeNames(32)
#### PCAMaximumAttributeNames(64)
PCAMaximumAttributeNames(128)
#### PCAMaximumAttributeNames(256)
PCAMaximumAttributeNames(512)
#### PCAMaximumAttributeNames(1024)

# ReliefF Attribute Evaluator numberOfNeighbors: Option -K [2,64][10]il
ReliefFAENumNeighbours(1)
#### ReliefFAENumNeighbours(2)
ReliefFAENumNeighbours(4)
ReliefFAENumNeighbours(10)
#### ReliefFAENumNeighbours(8)
ReliefFAENumNeighbours(16)
#### ReliefFAENumNeighbours(32)
ReliefFAENumNeighbours(64)

# ReliefF Attribute Evaluator sigma: Option -A [1,8][2]il
#### ReliefFAESigma(1)
ReliefFAESigma(2)
#### ReliefFAESigma(4)
ReliefFAESigma(8)


### BASE CLASSIFIERS ###

# Bayes Net searchAlgorithm: Option -Q {weka.classifiers.bayes.net.search.local.K2,weka.classifiers.bayes.net.search.local.HillClimber,weka.classifiers.bayes.net.search.local.LAGDHillClimber,weka.classifiers.bayes.net.search.local.SimulatedAnnealing,weka.classifiers.bayes.net.search.local.TabuSearch,weka.classifiers.bayes.net.search.local.TAN} [weka.classifiers.bayes.net.search.local.K2]
BNLocalSearch(weka.classifiers.bayes.net.search.local.K2)
#### BNLocalSearch(weka.classifiers.bayes.net.search.local.HillClimber)
BNLocalSearch(weka.classifiers.bayes.net.search.local.LAGDHillClimber)
#### BNLocalSearch(weka.classifiers.bayes.net.search.local.SimulatedAnnealing)
BNLocalSearch(weka.classifiers.bayes.net.search.local.TabuSearch)
#### BNLocalSearch(weka.classifiers.bayes.net.search.local.TAN)

# GP tolerance: Option -L [0.0001, 1] [0.1]l
GPTolerance(0.0001)
#### GPTolerance(0.001)
GPTolerance(0.01)
#### GPTolerance(0.1)
GPTolerance(1)

# GP filterType: Option -N {0,1,2} [0]
GPFilterType(0)
#### GPFilterType(1)
GPFilterType(2)

# Linear Regression Attribute Selection Method: Option -S {0,1,2} [0]
LinearRAttrSel(0)
#### LinearRAttrSel(1)
LinearRAttrSel(2)

# Linear Regression Ridge: Option -R [1e-7, 10] [1e-7]l
LinearRRidge(0.0000001)
#### LinearRRidge(0.000001)
LinearRRidge(0.00001)
#### LinearRRidge(0.0001)
LinearRRidge(0.001)
#### LinearRRidge(0.01)
LinearRRidge(0.1)
#### LinearRRidge(1)
LinearRRidge(10)

# Logistic Regression Ridge: Option -R [1e-12, 10] [1e-7]l
#### LogisticRRidge(0.000000000001)
LogisticRRidge(0.00000000001)
#### LogisticRRidge(0.0000000001)
LogisticRRidge(0.000000001)
#### LogisticRRidge(0.00000001)
LogisticRRidge(0.0000001)
#### LogisticRRidge(0.000001)
LogisticRRidge(0.00001)
#### LogisticRRidge(0.0001)
LogisticRRidge(0.001)
#### LogisticRRidge(0.01)
LogisticRRidge(0.1)
#### LogisticRRidge(1)
LogisticRRidge(10)

# Multilayer Perceptron Hidden Layer Type: Option -H {a,i,o,t} [a]
NNHiddenLayer(a)
#### NNHiddenLayer(i)
NNHiddenLayer(o)
#### NNHiddenLayer(t)

# Multilayer Perceptron Learning Rate: Option -L [0.1, 1] [0.3]
NNLearningRate(0.1)
#### NNLearningRate(0.2)
NNLearningRate(0.3)
#### NNLearningRate(0.4)
NNLearningRate(0.5)
#### NNLearningRate(0.6)
NNLearningRate(0.7)
#### NNLearningRate(0.8)
NNLearningRate(0.9)
#### NNLearningRate(1)

# Multilayer Perceptron Momentum: Option -M [0.1, 1] [0.2]
NNMomentum(0.1)
#### NNMomentum(0.2)
NNMomentum(0.3)
#### NNMomentum(0.4)
NNMomentum(0.5)
#### NNMomentum(0.6)
NNMomentum(0.7)
#### NNMomentum(0.8)
NNMomentum(0.9)
#### NNMomentum(1.0)

# SGD Learning Rate: Option -F {0,1,2}[0]
SGDLossFunction(0)
#### SGDLossFunction(1)
SGDLossFunction(2)

# SGD Learning Rate: Option -L [0.00001, 0.1] [0.01]l
SGDLearningRate(0.00001)
#### SGDLearningRate(0.0001)
SGDLearningRate(0.001)
#### SGDLearningRate(0.01)
SGDLearningRate(0.1)

# SGD Lambda: Option -R [1e-12, 10] [1e-4]l
#### SGDLambda(0.000000000001)
SGDLambda(0.00000000001)
#### SGDLambda(0.0000000001)
SGDLambda(0.000000001)
#### SGDLambda(0.00000001)
SGDLambda(0.0000001)
#### SGDLambda(0.000001)
SGDLambda(0.00001)
#### SGDLambda(0.0001)
SGDLambda(0.001)
#### SGDLambda(0.01)
SGDLambda(0.1)
#### SGDLambda(1)
SGDLambda(10)

# Simple Logistic Regression Weight Trim Beta: Option -W [0,1][0]
SLROptsWeightTrim(0.0)
#### SLROptsWeightTrim(0.1)
SLROptsWeightTrim(0.2)
#### SLROptsWeightTrim(0.3)
SLROptsWeightTrim(0.4)
#### SLROptsWeightTrim(0.5)
SLROptsWeightTrim(0.6)
#### SLROptsWeightTrim(0.7)
SLROptsWeightTrim(0.8)
#### SLROptsWeightTrim(0.9)
SLROptsWeightTrim(1.0)

# SMO, SMOreg complexity: Option -C [0.5,1.5][1.0]
SMOComplexity(0.5)
#### SMOComplexity(0.6)
SMOComplexity(0.7)
#### SMOComplexity(0.8)
SMOComplexity(0.9)
#### SMOComplexity(1.0)
SMOComplexity(1.1)
#### SMOComplexity(1.2)
SMOComplexity(1.3)
#### SMOComplexity(1.4)
SMOComplexity(1.5)

# SMO, SMOreg filterType: Option -N {0,1,2} [0]
SMOFilterType(0)
SMOFilterType(1)
#### SMOFilterType(2)

# GP, SMO, SMOreg kernel: Option -K {weka.classifiers.functions.supportVector.NormalizedPolyKernel,weka.classifiers.functions.supportVector.PolyKernel,weka.classifiers.functions.supportVector.Puk,weka.classifiers.functions.supportVector.RBFKernel}[weka.classifiers.functions.supportVector.NormalizedPolyKernel]
Kernel(weka.classifiers.functions.supportVector.NormalizedPolyKernel)
#### Kernel(weka.classifiers.functions.supportVector.PolyKernel)
Kernel(weka.classifiers.functions.supportVector.Puk)
#### Kernel(weka.classifiers.functions.supportVector.RBFKernel)

# SMOreg regOptimizer: Option -I {weka.classifiers.functions.supportVector.RegSMOImproved}[weka.classifiers.functions.supportVector.RegSMOImproved]
RegOptimizer(weka.classifiers.functions.supportVector.RegSMOImproved)

# Poly exponent: Option -E [0.2, 5] [1.0]
PolyKernelExponent(0.2)
#### PolyKernelExponent(1.0)
PolyKernelExponent(1.8)
#### PolyKernelExponent(2.6)
PolyKernelExponent(3.4)
#### PolyKernelExponent(4.2)
PolyKernelExponent(5.0)

# Puk sigma: Option -S [0.1, 10] [1.0]
PukKernelSigma(0.1)
PukKernelSigma(1)
#### PukKernelSigma(2)
PukKernelSigma(3)
#### PukKernelSigma(4)
PukKernelSigma(5)
#### PukKernelSigma(6)
PukKernelSigma(7)
#### PukKernelSigma(8)
PukKernelSigma(9)
#### PukKernelSigma(10)

# Puk omega: Option -O [0.1, 1] [1.0]
#### PukKernelOmega(0.1)
PukKernelOmega(0.2)
#### PukKernelOmega(0.3)
PukKernelOmega(0.4)
#### PukKernelOmega(0.5)
PukKernelOmega(0.6)
#### PukKernelOmega(0.7)
PukKernelOmega(0.8)
#### PukKernelOmega(0.9)
PukKernelOmega(1.0)

# RBF gamma: Option -G [0.0001,1] [0.01]l
RBFKernelGamma(0.0001
#### RBFKernelGamma(0.001
RBFKernelGamma(0.01
#### RBFKernelGamma(0.1
RBFKernelGamma(1.0

# Voted Perceptron Exponent: Option -E [0.2, 5] [1.0]
VPExponent(0.2)
#### VPExponent(1.0)
VPExponent(1.8)
#### VPExponent(2.6)
VPExponent(3.4)
#### VPExponent(4.2)
VPExponent(5.0)

# Voted Perceptron Iterations: Option -I [1, 10] [1]i
VPIterations(1)
#### VPIterations(2)
VPIterations(3)
#### VPIterations(4)
VPIterations(5)
#### VPIterations(6)
VPIterations(7)
#### VPIterations(8)
VPIterations(9)
#### VPIterations(10)

# Voted Perceptron maxK: Option -M [5000, 50000] [10000]il
VPMaxK(5000)
#### VPMaxK(10000)
VPMaxK(20000)
#### VPMaxK(50000)

# KNN numberOfNeighbors: Option -K [1,64] [1]il
KNNKNN(1)
#### KNNKNN(2)
KNNKNN(4)
#### KNNKNN(8)
KNNKNN(16)
#### KNNKNN(32)
KNNKNN(64)

# KStar globalBlend: Option -B [1,100] [20]i
KStarGlobalBlend(1)
#### KStarGlobalBlend(10)
KStarGlobalBlend(20)
#### KStarGlobalBlend(30)
KStarGlobalBlend(40)
#### KStarGlobalBlend(50)
KStarGlobalBlend(60)
#### KStarGlobalBlend(70)
KStarGlobalBlend(80)
#### KStarGlobalBlend(90)
KStarGlobalBlend(100)

# KStar missingMode: Option -M {a,d,m,n} [a]
KStarMissingMode(a)
#### KStarMissingMode(d)
KStarMissingMode(m)
#### KStarMissingMode(n)

# Decision Table evaluationMeasure: Option -E {acc,rmse,mae,auc} [acc]
DecTableEvalMeasure(acc)
#### DecTableEvalMeasure(rmse)
DecTableEvalMeasure(mae)
#### DecTableEvalMeasure(auc)

# Decision Table search: Option -S {weka.attributeSelection.BestFirst,weka.attributeSelection.GreedyStepwise,weka.attributeSelection.Ranker}[weka.attributeSelection.BestFirst]
DecTableSearch(weka.attributeSelection.BestFirst)
DecTableSearch(weka.attributeSelection.GreedyStepwise)
#DecTableSearch(weka.attributeSelection.Ranker) #### leads to exception in execution

# Decision Table crossVal: Option -X {1,2,3,4} [1]
DecTableCrossVal(1)
#### DecTableCrossVal(2)
DecTableCrossVal(3)
#### DecTableCrossVal(4)

# Ripper Rules minNo: Option -N [1, 5] [2.0]
RipperMinNo(1.0)
#### RipperMinNo(1.5)
RipperMinNo(2.0)
#### RipperMinNo(2.5)
RipperMinNo(3.0)
#### RipperMinNo(3.5)
RipperMinNo(4.0)
#### RipperMinNo(4.5)
RipperMinNo(5.0)

# Ripper Rules optimizations: Option -O [1,5][2]i
RipperOptimizations(1)
#### RipperOptimizations(2)
RipperOptimizations(3)
#### RipperOptimizations(4)
RipperOptimizations(5)

# M5 Rules minNumInstances: Option -M [1,64][4]il
M5RulesMinNumInstances(1)
#### M5RulesMinNumInstances(2)
M5RulesMinNumInstances(4)
#### M5RulesMinNumInstances(8)
M5RulesMinNumInstances(16)
#### M5RulesMinNumInstances(32)
M5RulesMinNumInstances(64)

# OneR Rules minBucketSize: Option -B [1,32][6]il
OneRMinBucketSize(1)
#### OneRMinBucketSize(2)
OneRMinBucketSize(4)
#### OneRMinBucketSize(8)
OneRMinBucketSize(16)
#### OneRMinBucketSize(32)

# PART Rules minNumObj: Option -M [1,64][2]il
PARTMinNumObj(1)
#### PARTMinNumObj(2)
PARTMinNumObj(4)
#### PARTMinNumObj(8)
PARTMinNumObj(16)
#### PARTMinNumObj(32)
PARTMinNumObj(64)

# PART Rules numFolds: Option -N [2,5][3]i
PARTNumFolds(2)
#### PARTNumFolds(3)
PARTNumFolds(4)
#### PARTNumFolds(5)

# Decision Tree C4.5 minNumObj: Option -M [1, 64][2]il
DTMinNumObj(1)
#### DTMinNumObj(2)
DTMinNumObj(4)
#### DTMinNumObj(8)
DTMinNumObj(16)
#### DTMinNumObj(32)
DTMinNumObj(64)

# Decision Tree C4.5 Confidence Factor: Option -C [0,1][0.25]
DTConfidenceFactor(0.01)
#### DTConfidenceFactor(0.1)
DTConfidenceFactor(0.2)
#### DTConfidenceFactor(0.3)
DTConfidenceFactor(0.4)
#### DTConfidenceFactor(0.5)
DTConfidenceFactor(0.6)
#### DTConfidenceFactor(0.7)
DTConfidenceFactor(0.8)
#### DTConfidenceFactor(0.9)
DTConfidenceFactor(0.99)

# Logistic Model Tree minNumInstances: Option -M [1,64][15]il
LMTMinNumInstances(1)
#### LMTMinNumInstances(2)
LMTMinNumInstances(4)
#### LMTMinNumInstances(8)
LMTMinNumInstances(16)
#### LMTMinNumInstances(32)
LMTMinNumInstances(64)

# Logistic Model Tree Weight Trim Beta: Option -W [0,1][0]
LMTWeightTrimBeta(0.0)
#### LMTWeightTrimBeta(0.1)
LMTWeightTrimBeta(0.2)
#### LMTWeightTrimBeta(0.3)
LMTWeightTrimBeta(0.4)
#### LMTWeightTrimBeta(0.5)
LMTWeightTrimBeta(0.6)
#### LMTWeightTrimBeta(0.7)
LMTWeightTrimBeta(0.8)
#### LMTWeightTrimBeta(0.9)
LMTWeightTrimBeta(1.0)

# M5Base Tree minNumInstances: Option -M [1,64][4]il
M5PMinNumInstances(1)
#### M5PMinNumInstances(2)
M5PMinNumInstances(4)
#### M5PMinNumInstances(8)
M5PMinNumInstances(16)
#### M5PMinNumInstances(32)
M5PMinNumInstances(64)

# Random Forest numIterations: Option -I [2, 256][10]il
RFNumIterations(2)
RFNumIterations(4)
#### RFNumIterations(8)
RFNumIterations(10)
#### RFNumIterations(16)
RFNumIterations(32)
#### RFNumIterations(64)
RFNumIterations(128)
#### RFNumIterations(256)

# Random Forest numFeatures: Option -K [1, 32][2]il
#### RFNumFeatures(1)
RFNumFeatures(2)
#### RFNumFeatures(4)
RFNumFeatures(8)
#### RFNumFeatures(16)
RFNumFeatures(32)

# Random Forest maxDepth: Option -depth [1, 20][2]i
RFMaxDepth(1)
#### RFMaxDepth(2)
RFMaxDepth(4)
#### RFMaxDepth(6)
RFMaxDepth(8)
#### RFMaxDepth(10)
RFMaxDepth(12)
#### RFMaxDepth(14)
RFMaxDepth(16)
#### RFMaxDepth(18)
RFMaxDepth(20)

# Random Tree KValue: Option -K [2, 32][2]il
RTKValue(2)
#### RTKValue(4)
RTKValue(8)
#### RTKValue(16)
RTKValue(32)

# Random Tree minNum: Option -M [1, 64][1]il
RTMinNum(1)
#### RTMinNum(2)
RTMinNum(4)
#### RTMinNum(8)
RTMinNum(16)
#### RTMinNum(32)
RTMinNum(64)

# Random Tree numFolds: Option -N [2, 5][3]i
#### RTNumFolds(2)
RTNumFolds(3)
#### RTNumFolds(4)
RTNumFolds(5)

# Random Tree maxDepth: Option -depth [2, 20][2]i
RTMaxDepth(2)
#### RTMaxDepth(4)
RTMaxDepth(6)
#### RTMaxDepth(8)
RTMaxDepth(10)
#### RTMaxDepth(12)
RTMaxDepth(14)
#### RTMaxDepth(16)
RTMaxDepth(18)
#### RTMaxDepth(20)

# REP Tree maxDepth: Option -L [2, 20][2]i
REPMaxDepth(2)
REPMaxDepth(4)
#### REPMaxDepth(6)
#### REPMaxDepth(8)
#### REPMaxDepth(10)
REPMaxDepth(12)
#### REPMaxDepth(14)
#### REPMaxDepth(16)
#### REPMaxDepth(18)
REPMaxDepth(20)

# REP Tree minNum: Option -M [1, 64][2]il
REPMinNum(1)
#### REPMinNum(2)
REPMinNum(4)
#### REPMinNum(8)
REPMinNum(16)
#### REPMinNum(32)
REPMinNum(64)

# REP Tree minVarianceProp: Option -V [1e-5, 1e-1][1e-3]l
REPMinVariance(0.00001)
#### REPMinVariance(0.0001)
REPMinVariance(0.001)
#### REPMinVariance(0.01)
REPMinVariance(0.1)


### META CLASSIFIERS ###

# Locally Weighted Learning nearestNeighbourSearch: Option -A {weka.core.neighboursearch.LinearNNSearch} [weka.core.neighboursearch.LinearNNSearch]
LWLNearestNeighbourSearch(weka.core.neighboursearch.LinearNNSearch)

# Locally Weighted Learning KNN: Option -K {-1,10,30,60,90,120} [-1]
LWLKNN(-1)
LWLKNN(10)
#### LWLKNN(30)
LWLKNN(60)
#### LWLKNN(90)
LWLKNN(120)

# Locally Weighted Learning weighingKernel: Option -U {0,1,2,3,4} [0]
LWLWeighingKernel(0)
#### LWLWeighingKernel(1)
LWLWeighingKernel(2)
#### LWLWeighingKernel(3)
LWLWeighingKernel(4)

# AdaBoost numIterations: Option -I [2,128][10]il
AdaBoostNumIterations(2)
#### AdaBoostNumIterations(4)
AdaBoostNumIterations(8)
#### AdaBoostNumIterations(10)
AdaBoostNumIterations(16)
#### AdaBoostNumIterations(32)
AdaBoostNumIterations(64)
#### AdaBoostNumIterations(128)

# AdaBoost weightThreshold: Option -P [50,100][100]i
AdaBoostWeightThreshold(50)
#### AdaBoostWeightThreshold(60)
AdaBoostWeightThreshold(70)
#### AdaBoostWeightThreshold(80)
AdaBoostWeightThreshold(90)
#### AdaBoostWeightThreshold(100)

# Additive Regression numIterations: Option -I [2,128][10]il
AddRegNumIterations(2)
#### AddRegNumIterations(4)
AddRegNumIterations(8)
#### AddRegNumIterations(10)
AddRegNumIterations(16)
#### AddRegNumIterations(32)
AddRegNumIterations(64)
#### AddRegNumIterations(128)

# Additive Regression shrinkage: Option -S [0,1.0][1]
AddRegShrinkage(0.0)
#### AddRegShrinkage(0.1)
AddRegShrinkage(0.2)
#### AddRegShrinkage(0.3)
AddRegShrinkage(0.4)
#### AddRegShrinkage(0.5)
AddRegShrinkage(0.6)
#### AddRegShrinkage(0.7)
AddRegShrinkage(0.8)
#### AddRegShrinkage(0.9)
AddRegShrinkage(1.0)

# Bagging numIterations: Option -I [2,128][10]il
BaggingNumIterations(2)
#### BaggingNumIterations(4)
BaggingNumIterations(8)
#### BaggingNumIterations(10)
BaggingNumIterations(16)
#### BaggingNumIterations(32)
BaggingNumIterations(64)
#### BaggingNumIterations(128)

# Bagging bagSizePercent: Option -P [10,200][100]i
BaggingBagSizePercent(10)
#### BaggingBagSizePercent(25)
BaggingBagSizePercent(50)
#### BaggingBagSizePercent(75)
BaggingBagSizePercent(100)
#### BaggingBagSizePercent(125)
BaggingBagSizePercent(150)
#### BaggingBagSizePercent(175)
BaggingBagSizePercent(200)

# LogitBoost numIterations: Option -I [2,128][10]il
LogitBoostNumIterations(2)
#### LogitBoostNumIterations(4)
LogitBoostNumIterations(8)
#### LogitBoostNumIterations(10)
LogitBoostNumIterations(16)
#### LogitBoostNumIterations(32)
LogitBoostNumIterations(64)
#### LogitBoostNumIterations(128)

# LogitBoost shrinkage: Option -S [0,1.0][1]
LogitBoostShrinkage(0.0)
#### LogitBoostShrinkage(0.1)
LogitBoostShrinkage(0.2)
#### LogitBoostShrinkage(0.3)
LogitBoostShrinkage(0.4)
#### LogitBoostShrinkage(0.5)
LogitBoostShrinkage(0.6)
#### LogitBoostShrinkage(0.7)
LogitBoostShrinkage(0.8)
#### LogitBoostShrinkage(0.9)
LogitBoostShrinkage(1.0)

# LogitBoost numRuns: Option -R [1,5][1]i
LogitBoostNumRuns(1)
#### LogitBoostNumRuns(2)
LogitBoostNumRuns(3)
#### LogitBoostNumRuns(4)
LogitBoostNumRuns(5)

# LogitBoost numFolds: Option -F [1,5][1]i
LogitBoostNumFolds(1)
#### LogitBoostNumFolds(2)
LogitBoostNumFolds(3)
#### LogitBoostNumFolds(4)
LogitBoostNumFolds(5)

# LogitBoost weightThreshold: Option -P [50,100][100]i
LogitBoostWeightThreshold(50)
#### LogitBoostWeightThreshold(60)
LogitBoostWeightThreshold(70)
#### LogitBoostWeightThreshold(80)
LogitBoostWeightThreshold(90)
#### LogitBoostWeightThreshold(100)

# MultiClass Classifier method: Option -M {0,1,2,3} [0]
MCCMethod(0)
MCCMethod(1)
MCCMethod(2)
MCCMethod(3)

# MultiClass Classifier randomWidthFactor: Option -R [0.5,4][2.0]
MCCRandomWidthFactor(0.5)
#### MCCRandomWidthFactor(1.0)
MCCRandomWidthFactor(1.5)
#### MCCRandomWidthFactor(2.0)
MCCRandomWidthFactor(2.5)
#### MCCRandomWidthFactor(3.0)
MCCRandomWidthFactor(3.5)
#### MCCRandomWidthFactor(4.0)

# Random Comittee numIterations: Option -I [2, 64][10]il
RandomComitteeNumIterations(2)
#### RandomComitteeNumIterations(4)
RandomComitteeNumIterations(8)
#### RandomComitteeNumIterations(10)
RandomComitteeNumIterations(16)
#### RandomComitteeNumIterations(32)
RandomComitteeNumIterations(64)

# Random Subspace numIterations: Option -I [2, 64][10]il
RandomSubspaceNumIterations(2)
#### RandomSubspaceNumIterations(4)
RandomSubspaceNumIterations(8)
#### RandomSubspaceNumIterations(10)
RandomSubspaceNumIterations(16)
#### RandomSubspaceNumIterations(32)
RandomSubspaceNumIterations(64)

# Random Subspace subSpaceSize: Option -P [0.1,1.0] [0.5]
RandomSubspaceSubSpaceSizePercent(0.1)
#### RandomSubspaceSubSpaceSizePercent(0.2)
RandomSubspaceSubSpaceSizePercent(0.3)
#### RandomSubspaceSubSpaceSizePercent(0.4)
RandomSubspaceSubSpaceSizePercent(0.5)
#### RandomSubspaceSubSpaceSizePercent(0.6)
RandomSubspaceSubSpaceSizePercent(0.7)
#### RandomSubspaceSubSpaceSizePercent(0.8)
RandomSubspaceSubSpaceSizePercent(0.9)
#### RandomSubspaceSubSpaceSizePercent(1.0)


### ENSEMBLE CLASSIFIERS ###

# Voting combinationRule: Option -R {AVG,PROD,MAJ,MIN,MAX} [AVG]
VoteCombinationRule(AVG)
#### VoteCombinationRule(PROD)
VoteCombinationRule(MAJ)
#### VoteCombinationRule(MIN)
VoteCombinationRule(MAX)


[Queries]

q1;x:Instances;;Instances(x);induce(x);(1000)

