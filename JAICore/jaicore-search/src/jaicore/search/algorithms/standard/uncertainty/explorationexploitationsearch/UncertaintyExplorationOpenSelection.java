package jaicore.search.algorithms.standard.uncertainty.explorationexploitationsearch;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jaicore.search.algorithms.standard.uncertainty.ISolutionDistanceMetric;
import jaicore.search.structure.core.Node;
import jaicore.search.structure.core.OpenCollection;
import jaicore.search.structure.core.PriorityQueueOpen;

public class UncertaintyExplorationOpenSelection<T, V extends Comparable<V>> implements OpenCollection<Node<T, V>> {

	private static final Logger logger = LoggerFactory.getLogger(UncertaintyExplorationOpenSelection.class);
	
	private final OpenCollection<Node<T, V>> primaryOpen;
	private final PriorityQueueOpen<Node<T, V>> secondaryOpen = new PriorityQueueOpen<>();
	private final ISolutionDistanceMetric<T> solutionDistanceMetric;
	private final IPhaseLengthAdjuster phaseLengthAdjuster;
	private final IExplorationCandidateSelector<T, V> candidateSelector;
	private int explorationPhaseLength = 10;
	private int exploitationPhaseLength = 50;
	double exploitationScoreThreshold = 0.05d;
	double explorationUncertaintyThreshold = 0.05d;
	private int selectedNodes = 0;
	private int exploredNodes = 0;
	private long timeout = 0;
	private long startTime;
	private boolean exploring = false;

	public UncertaintyExplorationOpenSelection(long timeout, int phaseInterval, double exploitationScoreThreshold, double explorationUncertaintyThreshold, IPhaseLengthAdjuster phaseLengthAdjuster, ISolutionDistanceMetric<T> solutionDistanceMetric, IExplorationCandidateSelector<T, V> candidateSelector) {
		super();
		this.primaryOpen = new PriorityQueueOpen<>();
		this.timeout = timeout;
		this.startTime = System.currentTimeMillis();
		int[] phaseLenghts = phaseLengthAdjuster.getInitialPhaseLengths(phaseInterval);
		assert phaseLenghts.length == 2;
		this.explorationPhaseLength = phaseLenghts[0];
		this.exploitationPhaseLength = phaseLenghts[1];
		this.exploitationScoreThreshold = exploitationScoreThreshold;
		this.explorationUncertaintyThreshold = explorationUncertaintyThreshold;
		this.phaseLengthAdjuster = phaseLengthAdjuster;
		this.solutionDistanceMetric = solutionDistanceMetric;
		this.candidateSelector = candidateSelector;
	}

	@Override
	public Node<T, V> peek() {
		if (!exploring) {
			selectedNodes++;
			if (selectedNodes % exploitationPhaseLength != 0) {
				logger.info("Exploiting ...");
				return selectCandidate(false);
			}

			List<Node<T, V>> explorationCandidates = candidateSelector.selectExplorationCandidates(primaryOpen, solutionDistanceMetric);

			/* enable exploration with the node selected by the explorer evaluator */
			try {
				logger.info("Entering exploration phase under {}", explorationCandidates);
			} catch (Exception e) {
				logger.error(e.getMessage());
			}
			exploring = true;
			exploredNodes = 0;
			primaryOpen.removeAll(explorationCandidates);
			secondaryOpen.clear();
			secondaryOpen.addAll(explorationCandidates);
			return selectCandidate(true);
		} else {
			exploredNodes++;
			if (exploredNodes > explorationPhaseLength || secondaryOpen.isEmpty()) {
				adjustPhaseLengths(System.currentTimeMillis() - this.startTime);
				exploring = false;
				primaryOpen.addAll(secondaryOpen);
				secondaryOpen.clear();
				logger.info("Entering exploitation phase");
				return selectCandidate(false);
			}
			Node<T, V> explorationCandidate = selectCandidate(true);
			logger.info("Exploring at node with uncertainty " + explorationCandidate.getAnnotation("uncertainty") + " ...");
			return explorationCandidate;
		}
	}

	private Node<T, V> selectCandidate(boolean isExploring) {
		Comparator<Node<T, V>> comparator = (n1, n2) -> {
			try {
				Object o1 = n1.getAnnotation("uncertainty");
				Object o2 = n2.getAnnotation("uncertainty");
				if (o1 != null && o1 instanceof Double && o2 != null && o2 instanceof Double) {
					Double u1 = (Double)o1;
					Double u2 = (Double)o2;
					V v1 = n1.getInternalLabel();
					V v2 = n2.getInternalLabel();
					if (isExploring) {
						if (Math.abs(u1 - u2) <= this.explorationUncertaintyThreshold) {
							return -1 * v1.compareTo(v2);
						} else {
							return Double.compare(u1, u2);
						}
					} else {
						if (v1 instanceof Double && v2 instanceof Double) {
							Double s1 = (Double)v1;
							Double s2 = (Double)v2;
							if (Math.abs(s1 - s2) <= this.exploitationScoreThreshold) {
								return Double.compare(u1, u2);
							} else {
								return v1.compareTo(v2);
							}
						} else {
							return v1.compareTo(v2);
						}
					}
				} else {
					return 0;
				}
			} catch (Exception e) {
				logger.error(e.getMessage());
				return 0;
			}
		};
		if (isExploring) {
			return secondaryOpen.stream().max(comparator).orElse(secondaryOpen.peek());
		} else {
			return primaryOpen.stream().min(comparator).orElse(primaryOpen.peek());
		}
	}
	
	private void adjustPhaseLengths(long passedTime) {
		int[] newPhaseLengths = this.phaseLengthAdjuster.adjustPhaseLength(explorationPhaseLength, exploitationPhaseLength, passedTime, this.timeout);
		assert newPhaseLengths.length == 2;
		this.explorationPhaseLength = newPhaseLengths[0];
		this.exploitationPhaseLength = newPhaseLengths[1];
	}
	
	@Override
	public boolean add(Node<T, V> node) {
		assert !contains(node) : "Node " + node + " is already there!";
		if (exploring) {
			return secondaryOpen.add(node);
		} else
			return primaryOpen.add(node);
	}

	@Override
	public boolean remove(Object node) {
		assert !(primaryOpen.contains(node) && secondaryOpen.contains(node)) : "A node (" + node + ") that is to be removed is in BOTH open lists!";
		if (exploring) {
			return secondaryOpen.remove(node) || primaryOpen.remove(node);
		} else {
			return primaryOpen.remove(node) || secondaryOpen.remove(node);
		}
	}

	@Override
	public boolean addAll(Collection<? extends Node<T, V>> arg0) {
		if (exploring) {
			return secondaryOpen.addAll(arg0);
		} else
			return primaryOpen.addAll(arg0);
	}

	@Override
	public void clear() {
		primaryOpen.clear();
		secondaryOpen.clear();
	}

	@Override
	public boolean contains(Object arg0) {
		return primaryOpen.contains(arg0) || secondaryOpen.contains(arg0);
	}

	@Override
	public boolean containsAll(Collection<?> arg0) {
		for (Object o : arg0) {
			if (!contains(o))
				return false;
		}
		return true;
	}

	@Override
	public boolean isEmpty() {
		return primaryOpen.isEmpty() && secondaryOpen.isEmpty();
	}

	@Override
	public Iterator<Node<T, V>> iterator() {
		return null;
	}

	@Override
	public boolean removeAll(Collection<?> arg0) {
		return primaryOpen.removeAll(arg0) && secondaryOpen.removeAll(arg0);
	}

	@Override
	public boolean retainAll(Collection<?> arg0) {
		return primaryOpen.retainAll(arg0) && secondaryOpen.retainAll(arg0);
	}

	@Override
	public int size() {
		return primaryOpen.size() + secondaryOpen.size();
	}

	@Override
	public Object[] toArray() {
		return primaryOpen.toArray();
	}

	@SuppressWarnings("unchecked")
	@Override
	public <X> X[] toArray(X[] arg0) {
		return (X[]) primaryOpen.toArray();
	}

}
