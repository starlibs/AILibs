//package jaicore.search.algorithms.standard.uncertainty;
//
//import static org.junit.Assert.assertEquals;
//
//import java.util.ArrayList;
//import java.util.List;
//import java.util.Map;
//import java.util.Random;
//
//import org.junit.Test;
//
//import jaicore.graphvisualizer.SimpleGraphVisualizationWindow;
//import jaicore.search.algorithms.parallel.parallelexploration.distributed.interfaces.SerializableGraphGenerator;
//import jaicore.search.algorithms.standard.bestfirst.BestFirst;
//import jaicore.search.algorithms.standard.bestfirst.model.Node;
//import jaicore.search.algorithms.standard.bestfirst.model.NodeExpansionDescription;
//import jaicore.search.algorithms.standard.bestfirst.model.NodeType;
//import jaicore.search.algorithms.standard.uncertainty.explorationexploitationsearch.BasicClockModelPhaseLengthAdjuster;
//import jaicore.search.algorithms.standard.uncertainty.explorationexploitationsearch.BasicExplorationCandidateSelector;
//import jaicore.search.algorithms.standard.uncertainty.explorationexploitationsearch.UncertaintyExplorationOpenSelection;
//import jaicore.search.core.interfaces.IPathUnification;
//import jaicore.search.core.interfaces.ISolutionEvaluator;
//import jaicore.search.structure.graphgenerator.NodeGoalTester;
//import jaicore.search.structure.graphgenerator.SingleRootGenerator;
//import jaicore.search.structure.graphgenerator.SuccessorGenerator;
//import jaicore.search.testproblems.nqueens.QueenNode;
//
//public class NQueensAsOptExplorationExploitation {
//
//	int dimension = 6;
//	int correctSolutions = 4;
//
//	@Test
//	public void testNQueensProblem() throws InterruptedException {
//
//		BestFirst<QueenNode, String, Double> search = new BestFirst<QueenNode, String, Double>(new SerializableGraphGenerator<QueenNode, String>() {
//
//			private static final long serialVersionUID = 1L;
//
//			@Override
//			public SingleRootGenerator<QueenNode> getRootGenerator() {
//				return () -> new QueenNode(dimension);
//			}
//
//			@Override
//			public SuccessorGenerator<QueenNode, String> getSuccessorGenerator() {
//				return n -> {
//					List<NodeExpansionDescription<QueenNode, String>> l = new ArrayList<>();
//					int currentRow = n.getPositions().size();
//					for (int i = 0; i < dimension; i++) {
//						l.add(new NodeExpansionDescription<>(n, new QueenNode(n, i), "(" + currentRow + ", " + i + ")", NodeType.OR));
//					}
//					return l;
//				};
//			}
//
//			@Override
//			public NodeGoalTester<QueenNode> getGoalTester() {
//				return n -> {
//					if (n.getNumberOfQueens() == dimension)
//						return true;
//					else
//						return false;
//
//				};
//			}
//
//			@Override
//			public boolean isSelfContained() {
//				return true;
//			}
//
//			@Override
//			public void setNodeNumbering(boolean nodenumbering) {
//				// TODO Auto-generated method stub
//
//			}
//
//		}, new UncertaintyRandomCompletionEvaluator<QueenNode, String, Double>(new Random(123l), 3, new IPathUnification<QueenNode>() {
//
//			@Override
//			public List<QueenNode> getSubsumingKnownPathCompletion(Map<List<QueenNode>, List<QueenNode>> knownPathCompletions, List<QueenNode> path) throws InterruptedException {
//				return null;
//			}
//		}, new ISolutionEvaluator<QueenNode, Double>() {
//			@Override
//			public Double evaluateSolution(List<QueenNode> solutionPath) throws Exception {
//				QueenNode leaf = solutionPath.get(solutionPath.size() - 1);
//				if (leaf.getNumberOfQueens() == dimension) {
//					return scoreSolution(leaf);
//				} else {
//					return 0.0d;
//				}
//			}
//
//			@Override
//			public boolean doesLastActionAffectScoreOfAnySubsequentSolution(List<QueenNode> partialSolutionPath) {
//				return true;
//			}
//		}, new BasicUncertaintySource<QueenNode, Double>()));
//		search.setOpen(new UncertaintyExplorationOpenSelection<QueenNode, Double>(100000000000l, 20, 0.05d, 0.05d, new BasicClockModelPhaseLengthAdjuster(), (solution1, solution2) -> {
//			double distance = 0.0d;
//			List<Integer> positions1 = solution1.get(solution1.size() - 1).getPositions();
//			List<Integer> positions2 = solution2.get(solution2.size() - 1).getPositions();
//			for (int i = 0; i < Math.min(positions1.size(), positions2.size()); i++) {
//				distance += Math.abs(positions1.get(i) - positions2.get(i));
//			}
//			return distance;
//		}, new BasicExplorationCandidateSelector<QueenNode, Double>(5.0d)));
//
//		SimpleGraphVisualizationWindow<Node<QueenNode, Double>,String> win = new SimpleGraphVisualizationWindow<Node<QueenNode, Double>,String>(search);
//		win.getPanel().setTooltipGenerator(n -> n.getPoint().toString());
//
//		int foundCorrectSolutions = 0;
//		int solutions = 0;
//		List<QueenNode> solution;
//		while (foundCorrectSolutions < correctSolutions) {
//			solution = search.nextSolution().getNodes();
//			solutions++;
//			if (scoreSolution(solution.get(solution.size() - 1)) == 0.0d) {
//				foundCorrectSolutions++;
//			}
//		}
//
//		System.out.println("done with " + foundCorrectSolutions + " correct solutions (" + solutions + " at all)");
//		assertEquals(foundCorrectSolutions, correctSolutions);
//	}
//
//	/**
//	 * Calculates the ratio of attacked queens for a chess board where all queens were placed.
//	 * 
//	 * @param n
//	 *            Chessboard with all placed queens.
//	 * @return Ratio of attacked queens.
//	 */
//	private double scoreSolution(QueenNode n) {
//		double attackedQueens = 0.0d;
//		List<Integer> positions = n.getPositions();
//
//		for (int i = 0; i < positions.size(); i++) {
//			boolean attacked = false;
//
//			for (int j = 0; j < positions.size(); j++) {
//				if (i != j) {
//					if (positions.get(i).equals(positions.get(j))) {
//						attacked = true;
//						break;
//					} else {
//						int x = i - j;
//						int y = positions.get(i) - positions.get(j);
//						if (((x * 1 - 1 * y) == 0) || ((x * (-1) - (-1) * y) == 0) || ((x * 1 - (-1) * y) == 0) || ((x * (-1) - 1 * y) == 0)) {
//							attacked = true;
//							break;
//						}
//					}
//				}
//			}
//
//			if (attacked) {
//				attackedQueens++;
//			} else {
//			}
//			attacked = false;
//		}
//		double rating = (attackedQueens / (double) dimension);
//		return rating;
//	}
//
//}
